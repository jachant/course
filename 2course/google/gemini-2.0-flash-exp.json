[
  {
    "code": "def minSum ( A , N ) : NEW_LINE INDENT mp = { } NEW_LINE sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += A [ i ] NEW_LINE if A [ i ] in mp : NEW_LINE INDENT mp [ A [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ A [ i ] ] = 1 NEW_LINE DEDENT DEDENT minSum = float ( ' inf ' ) NEW_LINE for it in mp : NEW_LINE INDENT minSum = min ( minSum , sum - ( it * mp [ it ] ) ) NEW_LINE DEDENT return minSum NEW_LINE DEDENT arr = [ 4 , 5 , 6 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE print ( minSum ( arr , N ) ) NEW_LINE",
    "ideal_answer": "Minimum sum possible by removing all occurrences of any array element",
    "generated_answer": "This function finds the minimum sum after removing duplicates"
  },
  {
    "code": "def maxAdjacent ( arr , N ) : NEW_LINE INDENT res = [ ] NEW_LINE for i in range ( 1 , N - 1 ) : NEW_LINE INDENT prev = arr [ 0 ] NEW_LINE maxi = - 1 * float ( ' inf ' ) NEW_LINE for j in range ( 1 , N ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT continue NEW_LINE DEDENT maxi = max ( maxi , abs ( arr [ j ] - prev ) ) NEW_LINE prev = arr [ j ] NEW_LINE DEDENT res . append ( maxi ) NEW_LINE DEDENT for x in res : NEW_LINE INDENT print ( x , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT arr = [ 1 , 3 , 4 , 7 , 8 ] NEW_LINE N = len ( arr ) NEW_LINE maxAdjacent ( arr , N ) NEW_LINE",
    "ideal_answer": "Maximum difference between a pair of adjacent elements by excluding every element once",
    "generated_answer": "This code finds maximum adjacent differences in an array"
  },
  {
    "code": "def findSize ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( N == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT Size = 2 * findSize ( N // 2 ) + 1 NEW_LINE return Size NEW_LINE DEDENT def CountOnes ( N , L , R ) : NEW_LINE INDENT if ( L > R ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( N <= 1 ) : NEW_LINE INDENT return N NEW_LINE DEDENT ret = 0 NEW_LINE M = N // 2 NEW_LINE Siz_M = findSize ( M ) NEW_LINE if ( L <= Siz_M ) : NEW_LINE INDENT ret += CountOnes ( N // 2 , L , min ( Siz_M , R ) ) NEW_LINE DEDENT if ( L <= Siz_M + 1 and Siz_M + 1 <= R ) : NEW_LINE INDENT ret += N % 2 NEW_LINE DEDENT if ( Siz_M + 1 < R ) : NEW_LINE INDENT ret += CountOnes ( N // 2 , max ( 1 , L - Siz_M - 1 ) , R - Siz_M - 1 ) NEW_LINE DEDENT return ret NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 7 NEW_LINE L = 2 NEW_LINE R = 5 NEW_LINE print ( CountOnes ( N , L , R ) ) NEW_LINE DEDENT",
    "ideal_answer": "Count 1 s present in a range of indices [ L , R ] in a given array",
    "generated_answer": "This function calculates ones in a fractal binary representation"
  },
  {
    "code": "def prime ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i * i > n : NEW_LINE INDENT break NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def minDivisior ( n ) : NEW_LINE INDENT if ( prime ( n ) ) : NEW_LINE INDENT print ( 1 , n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i * i > n : NEW_LINE INDENT break NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT print ( n // i , n // i * ( i - 1 ) ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT N = 4 NEW_LINE minDivisior ( N ) NEW_LINE",
    "ideal_answer": "Find the pair ( a , b ) with minimum LCM such that their sum is equal to N",
    "generated_answer": "This code finds the smallest divisor for a given number"
  },
  {
    "code": "import sys NEW_LINE Landau = - sys . maxsize - 1 NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return ( a * b ) // gcd ( a , b ) NEW_LINE DEDENT def findLCM ( arr ) : NEW_LINE INDENT global Landau NEW_LINE nth_lcm = arr [ 0 ] NEW_LINE for i in range ( 1 , len ( arr ) ) : NEW_LINE INDENT nth_lcm = lcm ( nth_lcm , arr [ i ] ) NEW_LINE DEDENT Landau = max ( Landau , nth_lcm ) NEW_LINE DEDENT def findWays ( arr , i , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT findLCM ( arr ) NEW_LINE DEDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT arr . append ( j ) NEW_LINE findWays ( arr , j , n - j ) NEW_LINE arr . pop ( ) NEW_LINE DEDENT DEDENT def Landau_function ( n ) : NEW_LINE INDENT arr = [ ] NEW_LINE findWays ( arr , 1 , n ) NEW_LINE print ( Landau ) NEW_LINE DEDENT N = 4 NEW_LINE Landau_function ( N ) NEW_LINE",
    "ideal_answer": "Find Landau 's function for a given number N",
    "generated_answer": "This code finds the Landau function's value for a given number"
  },
  {
    "code": "def isPrime ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( ( n % 2 == 0 ) or ( n % 3 == 0 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( ( n % i == 0 ) or ( n % ( i + 2 ) == 0 ) ) : NEW_LINE INDENT return False ; NEW_LINE i += 6 NEW_LINE DEDENT DEDENT return true ; NEW_LINE DEDENT def checkExpression ( n ) : NEW_LINE INDENT if ( isPrime ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE checkExpression ( N ) NEW_LINE DEDENT",
    "ideal_answer": "Check if the remainder of N",
    "generated_answer": "This code checks primality using an expression"
  },
  {
    "code": "def checkArray ( n , k , arr ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if ( cnt >= k and cnt % 2 == k % 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 3 , 4 , 7 , 5 , 3 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE k = 4 NEW_LINE if ( checkArray ( n , k , arr ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
    "ideal_answer": "Check if it is possible to split given Array into K odd",
    "generated_answer": "This code checks odd numbers in an array using given conditions"
  },
  {
    "code": "from math import * NEW_LINE def func ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE maxx = 0 NEW_LINE freq = [ 0 ] * 100005 NEW_LINE temp = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE freq [ temp ] += 1 NEW_LINE maxx = max ( maxx , temp ) NEW_LINE DEDENT for i in range ( 1 , maxx + 1 ) : NEW_LINE INDENT freq [ i ] += freq [ i - 1 ] NEW_LINE DEDENT for i in range ( 1 , maxx + 1 ) : NEW_LINE INDENT if ( freq [ i ] ) : NEW_LINE INDENT value = 0 NEW_LINE cur = ceil ( 0.5 * i ) - 1.0 NEW_LINE j = 1.5 NEW_LINE while ( 1 ) : NEW_LINE INDENT val = min ( maxx , ( ceil ( i * j ) - 1.0 ) ) NEW_LINE times = ( freq [ i ] - freq [ i - 1 ] ) NEW_LINE con = j - 0.5 NEW_LINE ans += times * con * ( freq [ int ( val ) ] - freq [ int ( cur ) ] ) NEW_LINE cur = val NEW_LINE if ( val == maxx ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT DEDENT return int ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( func ( arr , n ) ) NEW_LINE DEDENT",
    "ideal_answer": "Sum of division of the possible pairs for the given Array",
    "generated_answer": "This code calculates the number of intersecting line pairs"
  },
  {
    "code": "def insert_element ( a , n ) : NEW_LINE INDENT Xor = 0 NEW_LINE Sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Xor ^= a [ i ] NEW_LINE Sum += a [ i ] NEW_LINE DEDENT if ( Sum == 2 * Xor ) : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT if ( Xor == 0 ) : NEW_LINE INDENT print ( 1 ) NEW_LINE print ( Sum ) NEW_LINE return NEW_LINE DEDENT num1 = Sum + Xor NEW_LINE num2 = Xor NEW_LINE print ( 2 ) NEW_LINE print ( num1 , num2 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE insert_element ( a , n ) NEW_LINE DEDENT",
    "ideal_answer": "Count of elements to be inserted to make Array sum twice the XOR of Array",
    "generated_answer": "This function calculates the numbers to insert to sum to xor"
  },
  {
    "code": "def checkSolution ( a , b , c ) : NEW_LINE INDENT if ( a == c ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT a = 2 ; b = 0 ; c = 2 ; NEW_LINE checkSolution ( a , b , c ) ; NEW_LINE",
    "ideal_answer": "Check if roots of a Quadratic Equation are reciprocal of each other or not",
    "generated_answer": "This code demonstrates checking simple equality"
  },
  {
    "code": "from math import * NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT sr = sqrt ( x ) NEW_LINE return ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE DEDENT def checkSunnyNumber ( N ) : NEW_LINE INDENT if ( isPerfectSquare ( N + 1 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 8 NEW_LINE checkSunnyNumber ( N ) NEW_LINE DEDENT",
    "ideal_answer": "Sunny Number",
    "generated_answer": "This code checks if a number is a sunny number"
  },
  {
    "code": "def countValues ( n ) : NEW_LINE INDENT answer = 0 NEW_LINE for i in range ( 2 , n + 1 , 1 ) : NEW_LINE INDENT k = n NEW_LINE while ( k >= i ) : NEW_LINE INDENT if ( k % i == 0 ) : NEW_LINE INDENT k //= i NEW_LINE DEDENT else : NEW_LINE INDENT k -= i NEW_LINE DEDENT DEDENT if ( k == 1 ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 6 NEW_LINE print ( countValues ( N ) ) NEW_LINE DEDENT",
    "ideal_answer": "Count the numbers which can convert N to 1 using given operation",
    "generated_answer": "This code counts values based on division and remainder conditions"
  },
  {
    "code": "def printKNumbers ( N , K ) : NEW_LINE INDENT for i in range ( K - 1 ) : NEW_LINE INDENT print ( 1 , end = ' ▁ ' ) NEW_LINE DEDENT print ( N - K + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT ( N , K ) = ( 10 , 3 ) NEW_LINE printKNumbers ( N , K ) NEW_LINE DEDENT",
    "ideal_answer": "Find K numbers with sum equal to N and sum of their squares maximized",
    "generated_answer": "This code prints k unique numbers summing to n"
  },
  {
    "code": "def NthSmallest ( K ) : NEW_LINE INDENT Q = [ ] NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT Q . append ( i ) NEW_LINE DEDENT for i in range ( 1 , K + 1 ) : NEW_LINE INDENT x = Q [ 0 ] NEW_LINE Q . remove ( Q [ 0 ] ) NEW_LINE if ( x % 10 != 0 ) : NEW_LINE INDENT Q . append ( x * 10 + x % 10 - 1 ) NEW_LINE DEDENT Q . append ( x * 10 + x % 10 ) NEW_LINE if ( x % 10 != 9 ) : NEW_LINE INDENT Q . append ( x * 10 + x % 10 + 1 ) NEW_LINE DEDENT DEDENT return x NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 16 NEW_LINE print ( NthSmallest ( N ) ) NEW_LINE DEDENT",
    "ideal_answer": "Print Nth Stepping or Autobiographical number",
    "generated_answer": "This code finds nth smallest number with special properties"
  },
  {
    "code": "from math import sqrt NEW_LINE def nearest ( n ) : NEW_LINE INDENT prevSquare = int ( sqrt ( n ) ) ; NEW_LINE nextSquare = prevSquare + 1 ; NEW_LINE prevSquare = prevSquare * prevSquare ; NEW_LINE nextSquare = nextSquare * nextSquare ; NEW_LINE ans = ( prevSquare - n ) if ( n - prevSquare ) < ( nextSquare - n ) else ( nextSquare - n ) ; NEW_LINE return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 14 ; NEW_LINE print ( nearest ( n ) ) ; NEW_LINE n = 16 ; NEW_LINE print ( nearest ( n ) ) ; NEW_LINE n = 18 ; NEW_LINE print ( nearest ( n ) ) ; NEW_LINE DEDENT",
    "ideal_answer": "Least number to be added to or subtracted from N to make it a Perfect Square",
    "generated_answer": "This code determines the nearest perfect square to a given number"
  },
  {
    "code": "from math import acos NEW_LINE def printValueOfPi ( N ) : NEW_LINE INDENT b = ' { : . ' + str ( N ) + ' f } ' NEW_LINE pi = b . format ( 2 * acos ( 0.0 ) ) NEW_LINE print ( pi ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 43 ; NEW_LINE printValueOfPi ( N ) ; NEW_LINE DEDENT",
    "ideal_answer": "Value of Pi ( Î ) up to 50 decimal places",
    "generated_answer": "This code prints PI up to N digits"
  },
  {
    "code": "import math NEW_LINE def decBinary ( arr , n ) : NEW_LINE INDENT k = int ( math . log2 ( n ) ) NEW_LINE while ( n > 0 ) : NEW_LINE INDENT arr [ k ] = n % 2 NEW_LINE k = k - 1 NEW_LINE n = n // 2 NEW_LINE DEDENT DEDENT def binaryDec ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT ans = ans + ( arr [ i ] << ( n - i - 1 ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def getNum ( n , k ) : NEW_LINE INDENT l = int ( math . log2 ( n ) ) + 1 NEW_LINE a = [ 0 for i in range ( 0 , l ) ] NEW_LINE decBinary ( a , n ) NEW_LINE if ( k > l ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( a [ k - 1 ] == 0 ) : NEW_LINE INDENT a [ k - 1 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT a [ k - 1 ] = 0 NEW_LINE DEDENT return binaryDec ( a , l ) NEW_LINE DEDENT n = 56 NEW_LINE k = 2 NEW_LINE print ( getNum ( n , k ) ) NEW_LINE",
    "ideal_answer": "Invert the Kth most significant bit of N",
    "generated_answer": "This code converts a number to binary and modifies a bit"
  },
  {
    "code": "MAX = 1000000 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE result = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE fact = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE def preCompute ( ) : NEW_LINE INDENT fact [ 0 ] = 1 NEW_LINE result [ 0 ] = 1 NEW_LINE for i in range ( 1 , MAX + 1 ) : NEW_LINE INDENT fact [ i ] = ( ( fact [ i - 1 ] % MOD ) * i ) % MOD NEW_LINE result [ i ] = ( ( result [ i - 1 ] % MOD ) * ( fact [ i ] % MOD ) ) % MOD NEW_LINE DEDENT DEDENT def performQueries ( q , n ) : NEW_LINE INDENT preCompute ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( result [ q [ i ] ] ) NEW_LINE DEDENT DEDENT q = [ 4 , 5 ] NEW_LINE n = len ( q ) NEW_LINE performQueries ( q , n ) NEW_LINE",
    "ideal_answer": "Queries for the product of first N factorials",
    "generated_answer": "This code calculates a summation based on precomputed factorials"
  },
  {
    "code": "import sys NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b ; NEW_LINE DEDENT return gcd ( b % a , a ) ; NEW_LINE DEDENT def divTermCount ( a , b , c , num ) : NEW_LINE INDENT return ( ( num / a ) + ( num / b ) + ( num / c ) - ( num / ( ( a * b ) / gcd ( a , b ) ) ) - ( num / ( ( c * b ) / gcd ( c , b ) ) ) - ( num / ( ( a * c ) / gcd ( a , c ) ) ) + ( num / ( ( a * b * c ) / gcd ( gcd ( a , b ) , c ) ) ) ) ; NEW_LINE DEDENT def findNthTerm ( a , b , c , n ) : NEW_LINE INDENT low = 1 ; high = sys . maxsize ; mid = 0 ; NEW_LINE while ( low < high ) : NEW_LINE INDENT mid = low + ( high - low ) / 2 ; NEW_LINE if ( divTermCount ( a , b , c , mid ) < n ) : NEW_LINE INDENT low = mid + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT high = mid ; NEW_LINE DEDENT DEDENT return int ( low ) ; NEW_LINE DEDENT a = 2 ; b = 3 ; c = 5 ; n = 100 ; NEW_LINE print ( findNthTerm ( a , b , c , n ) ) ; NEW_LINE",
    "ideal_answer": "Nth number in a set of multiples of A , B or C",
    "generated_answer": "This code finds the Nth term divisible by a b or c"
  },
  {
    "code": "def calculate_angle ( n , i , j , k ) : NEW_LINE INDENT x , y = 0 , 0 NEW_LINE if ( i < j ) : NEW_LINE INDENT x = j - i NEW_LINE DEDENT else : NEW_LINE INDENT x = j + n - i NEW_LINE DEDENT if ( j < k ) : NEW_LINE INDENT y = k - j NEW_LINE DEDENT else : NEW_LINE INDENT y = k + n - j NEW_LINE DEDENT ang1 = ( 180 * x ) // n NEW_LINE ang2 = ( 180 * y ) // n NEW_LINE ans = 180 - ang1 - ang2 NEW_LINE return ans NEW_LINE DEDENT n = 5 NEW_LINE a1 = 1 NEW_LINE a2 = 2 NEW_LINE a3 = 5 NEW_LINE print ( calculate_angle ( n , a1 , a2 , a3 ) ) NEW_LINE",
    "ideal_answer": "Angle between 3 given vertices in a n",
    "generated_answer": "This code calculates an angle based on indices in a sequence"
  },
  {
    "code": "def Loss ( SP , P ) : NEW_LINE INDENT loss = 0 NEW_LINE loss = ( ( 2 * P * P * SP ) / ( 100 * 100 - P * P ) ) NEW_LINE print ( \" Loss ▁ = \" , round ( loss , 3 ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT SP , P = 2400 , 30 NEW_LINE Loss ( SP , P ) NEW_LINE DEDENT",
    "ideal_answer": "Loss when two items are sold at same price and same percentage profit / loss",
    "generated_answer": "This code calculates the profit on loss based on SP and profits"
  },
  {
    "code": "MAXN = 1000001 NEW_LINE spf = [ i for i in range ( MAXN ) ] NEW_LINE hash1 = [ 0 for i in range ( MAXN ) ] NEW_LINE def sieve ( ) : NEW_LINE INDENT for i in range ( 4 , MAXN , 2 ) : NEW_LINE INDENT spf [ i ] = 2 NEW_LINE DEDENT for i in range ( 3 , MAXN ) : NEW_LINE INDENT if i * i >= MAXN : NEW_LINE INDENT break NEW_LINE DEDENT if ( spf [ i ] == i ) : NEW_LINE INDENT for j in range ( i * i , MAXN , i ) : NEW_LINE INDENT if ( spf [ j ] == j ) : NEW_LINE INDENT spf [ j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def getFactorization ( x ) : NEW_LINE INDENT while ( x != 1 ) : NEW_LINE INDENT temp = spf [ x ] NEW_LINE if ( x % temp == 0 ) : NEW_LINE INDENT hash1 [ spf [ x ] ] += 1 NEW_LINE x = x // spf [ x ] NEW_LINE DEDENT while ( x % temp == 0 ) : NEW_LINE INDENT x = x // temp NEW_LINE DEDENT DEDENT DEDENT def check ( x ) : NEW_LINE INDENT while ( x != 1 ) : NEW_LINE INDENT temp = spf [ x ] NEW_LINE if ( x % temp == 0 and hash1 [ temp ] > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( x % temp == 0 ) : NEW_LINE INDENT x = x // temp NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def hasValidNum ( arr , n ) : NEW_LINE INDENT sieve ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT getFactorization ( arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( check ( arr [ i ] ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT arr = [ 2 , 8 , 4 , 10 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE if ( hasValidNum ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
    "ideal_answer": "Check for an array element that is co",
    "generated_answer": "This code filters prime factors based on frequency conditions"
  },
  {
    "code": "def countWays ( N ) : NEW_LINE INDENT E = ( N * ( N - 1 ) ) / 2 NEW_LINE if ( N == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return int ( pow ( 2 , E - 1 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE print ( countWays ( N ) ) NEW_LINE DEDENT",
    "ideal_answer": "Ways to Remove Edges from a Complete Graph to make Odd Edges",
    "generated_answer": "This code calculates the number of connected component options"
  },
  {
    "code": "l = [ [ 0 for i in range ( 1001 ) ] for j in range ( 1001 ) ] NEW_LINE def initialize ( ) : NEW_LINE INDENT l [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , 1001 ) : NEW_LINE INDENT l [ i ] [ 0 ] = 1 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT l [ i ] [ j ] = ( l [ i - 1 ] [ j - 1 ] + l [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT def nCr ( n , r ) : NEW_LINE INDENT return l [ n ] [ r ] NEW_LINE DEDENT initialize ( ) NEW_LINE n = 8 NEW_LINE r = 3 NEW_LINE print ( nCr ( n , r ) ) NEW_LINE",
    "ideal_answer": "Calculate nCr using Pascal 's Triangle",
    "generated_answer": "This code demonstrates the calculation of nCr value"
  },
  {
    "code": "def minAbsDiff ( n ) : NEW_LINE INDENT mod = n % 4 ; NEW_LINE if ( mod == 0 or mod == 3 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT return 1 ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 ; NEW_LINE print ( minAbsDiff ( n ) ) NEW_LINE DEDENT",
    "ideal_answer": "Closest sum partition ( into two subsets ) of numbers from 1 to n",
    "generated_answer": "This code calculates the minimum absolute difference in a sequence"
  },
  {
    "code": "def check ( s ) : NEW_LINE INDENT freq = [ 0 ] * 10 NEW_LINE while ( s != 0 ) : NEW_LINE INDENT r = s % 10 NEW_LINE s = s // 10 NEW_LINE freq [ r ] += 1 NEW_LINE DEDENT xor = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT xor = xor ^ freq [ i ] NEW_LINE DEDENT if ( xor == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT s = 122233 NEW_LINE if ( check ( s ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
    "ideal_answer": "Check if the Xor of the frequency of all digits of a number N is zero or not",
    "generated_answer": "This code calculates if an integer has even or odd frequencies"
  },
  {
    "code": "def printLines ( n , k ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( k * ( 6 * i + 1 ) , k * ( 6 * i + 2 ) , k * ( 6 * i + 3 ) , k * ( 6 * i + 5 ) ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , k = 2 , 2 NEW_LINE printLines ( n , k ) NEW_LINE DEDENT",
    "ideal_answer": "Print N lines of 4 numbers such that every pair among 4 numbers has a GCD K",
    "generated_answer": "This code prints array of numbers based on k value and n"
  },
  {
    "code": "def calculateSum ( n ) : NEW_LINE INDENT return ( 2 ** ( n + 1 ) + n - 2 ) NEW_LINE DEDENT n = 4 NEW_LINE print ( \" Sum ▁ = \" , calculateSum ( n ) ) NEW_LINE",
    "ideal_answer": "Sum of first n term of Series 3 , 5 , 9 , 17 , 33. ...",
    "generated_answer": "This code finds a sum involving bitwise operations"
  },
  {
    "code": "mod = 1000000007 NEW_LINE def count_special ( n ) : NEW_LINE INDENT fib = [ 0 for i in range ( n + 1 ) ] NEW_LINE fib [ 0 ] = 1 NEW_LINE fib [ 1 ] = 2 NEW_LINE for i in range ( 2 , n + 1 , 1 ) : NEW_LINE INDENT fib [ i ] = ( fib [ i - 1 ] % mod + fib [ i - 2 ] % mod ) % mod NEW_LINE DEDENT return fib [ n ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE print ( count_special ( n ) ) NEW_LINE DEDENT",
    "ideal_answer": "Count the number of Special Strings of a given length N",
    "generated_answer": "This code calculates a solution using dynamic programming and recursion"
  },
  {
    "code": "mod = 1e9 + 7 ; NEW_LINE def ways ( i , arr , n ) : NEW_LINE INDENT if ( i == n - 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT sum = 0 ; NEW_LINE for j in range ( 1 , arr [ i ] + 1 ) : NEW_LINE INDENT if ( i + j < n ) : NEW_LINE INDENT sum += ( ways ( i + j , arr , n ) ) % mod ; NEW_LINE sum %= mod ; NEW_LINE DEDENT DEDENT return int ( sum % mod ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 3 , 1 , 4 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( ways ( 0 , arr , n ) ) ; NEW_LINE DEDENT",
    "ideal_answer": "Counts Path in an Array",
    "generated_answer": "This code demonstrates how to calculate partition numbers"
  },
  {
    "code": "mod = 10 ** 9 + 7 NEW_LINE def ways ( arr , n ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ n - 1 ] = 1 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT dp [ i ] = 0 NEW_LINE j = 1 NEW_LINE while ( ( j + i ) < n and j <= arr [ i ] ) : NEW_LINE INDENT dp [ i ] += dp [ i + j ] NEW_LINE dp [ i ] %= mod NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return dp [ 0 ] % mod NEW_LINE DEDENT arr = [ 5 , 3 , 1 , 4 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( ways ( arr , n ) % mod ) NEW_LINE",
    "ideal_answer": "Counts Path in an Array",
    "generated_answer": "This code finds the longest increasing path in a matrix"
  },
  {
    "code": "def countSum ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE count_odd = 0 NEW_LINE count_even = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( arr [ i - 1 ] % 2 == 0 ) : NEW_LINE INDENT count_even = count_even + count_even + 1 NEW_LINE count_odd = count_odd + count_odd NEW_LINE DEDENT else : NEW_LINE INDENT temp = count_even NEW_LINE count_even = count_even + count_odd NEW_LINE count_odd = count_odd + temp + 1 NEW_LINE DEDENT DEDENT return ( count_even , count_odd ) NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 3 ] ; NEW_LINE n = len ( arr ) NEW_LINE count_even , count_odd = countSum ( arr , n ) ; NEW_LINE print ( \" EvenSum ▁ = ▁ \" , count_even , \" ▁ OddSum ▁ = ▁ \" , count_odd ) NEW_LINE",
    "ideal_answer": "Number of Subsequences with Even and Odd Sum",
    "generated_answer": "This code counts all possible paths in a mXn grid"
  },
  {
    "code": "MAX = 10 NEW_LINE def numToVec ( N ) : NEW_LINE INDENT digit = [ ] NEW_LINE while ( N != 0 ) : NEW_LINE INDENT digit . append ( N % 10 ) NEW_LINE N = N // 10 NEW_LINE DEDENT if ( len ( digit ) == 0 ) : NEW_LINE INDENT digit . append ( 0 ) NEW_LINE DEDENT digit = digit [ : : - 1 ] NEW_LINE return digit NEW_LINE DEDENT def solve ( A , B , C ) : NEW_LINE INDENT d , d2 = 0 , 0 NEW_LINE digit = numToVec ( C ) NEW_LINE d = len ( A ) NEW_LINE if ( B > len ( digit ) or d == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( B < len ( digit ) ) : NEW_LINE INDENT if ( A [ 0 ] == 0 and B != 1 ) : NEW_LINE INDENT return ( d - 1 ) * pow ( d , B - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return pow ( d , B ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT dp = [ 0 for i in range ( B + 1 ) ] NEW_LINE lower = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE for i in range ( d ) : NEW_LINE INDENT lower [ A [ i ] + 1 ] = 1 NEW_LINE DEDENT for i in range ( 1 , MAX + 1 ) : NEW_LINE INDENT lower [ i ] = lower [ i - 1 ] + lower [ i ] NEW_LINE DEDENT flag = True NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( 1 , B + 1 ) : NEW_LINE INDENT d2 = lower [ digit [ i - 1 ] ] NEW_LINE dp [ i ] = dp [ i - 1 ] * d NEW_LINE if ( i == 1 and A [ 0 ] == 0 and B != 1 ) : NEW_LINE INDENT d2 = d2 - 1 NEW_LINE DEDENT if ( flag ) : NEW_LINE INDENT dp [ i ] += d2 NEW_LINE DEDENT flag = ( flag & ( lower [ digit [ i - 1 ] + 1 ] == lower [ digit [ i - 1 ] ] + 1 ) ) NEW_LINE DEDENT return dp [ B ] NEW_LINE DEDENT DEDENT A = [ 0 , 1 , 2 , 5 ] NEW_LINE N = 2 NEW_LINE k = 21 NEW_LINE print ( solve ( A , N , k ) ) NEW_LINE",
    "ideal_answer": "Count of integers of length N and value less than K such that they contain digits only from the given set",
    "generated_answer": "This code finds the maximum possible gold collected in matrix traversal"
  },
  {
    "code": "import numpy as np NEW_LINE def solve ( dp , wt , K , M , used ) : NEW_LINE INDENT if ( wt < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( wt == 0 ) : NEW_LINE INDENT if ( used ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if ( dp [ wt ] [ used ] != - 1 ) : NEW_LINE INDENT return dp [ wt ] [ used ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , K + 1 ) : NEW_LINE INDENT if ( i >= M ) : NEW_LINE INDENT ans += solve ( dp , wt - i , K , M , used 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += solve ( dp , wt - i , K , M , used ) NEW_LINE DEDENT DEDENT dp [ wt ] [ used ] = ans NEW_LINE return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT W = 3 NEW_LINE K = 3 NEW_LINE M = 2 NEW_LINE dp = np . ones ( ( W + 1 , 2 ) ) ; NEW_LINE dp = - 1 * dp NEW_LINE print ( solve ( dp , W , K , M , 0 ) ) NEW_LINE DEDENT",
    "ideal_answer": "Number of Paths of Weight W in a K",
    "generated_answer": "This method calculates the minimum adjustments in an array"
  },
  {
    "code": "def partitions ( n ) : NEW_LINE INDENT p = [ 0 ] * ( n + 1 ) NEW_LINE p [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT k = 1 NEW_LINE while ( ( k * ( 3 * k - 1 ) ) / 2 <= i ) : NEW_LINE INDENT p [ i ] += ( ( 1 if k % 2 else - 1 ) * p [ i - ( k * ( 3 * k - 1 ) ) // 2 ] ) NEW_LINE if ( k > 0 ) : NEW_LINE INDENT k *= - 1 NEW_LINE DEDENT else : NEW_LINE INDENT k = 1 - k NEW_LINE DEDENT DEDENT DEDENT return p [ n ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 20 NEW_LINE print ( partitions ( N ) ) NEW_LINE DEDENT",
    "ideal_answer": "Ways to write N as sum of two or more positive integers",
    "generated_answer": "The code finds the number of combinations under given conditions"
  },
  {
    "code": "MAX = 20 NEW_LINE def LIP ( dp , mat , n , m , x , y ) : NEW_LINE INDENT if ( dp [ x ] [ y ] < 0 ) : NEW_LINE INDENT result = 0 NEW_LINE if ( x == n - 1 and y == m - 1 ) : NEW_LINE INDENT dp [ x ] [ y ] = 1 NEW_LINE return dp [ x ] [ y ] NEW_LINE DEDENT if ( x == n - 1 or y == m - 1 ) : NEW_LINE INDENT result = 1 NEW_LINE DEDENT if ( x + 1 < n and mat [ x ] [ y ] < mat [ x + 1 ] [ y ] ) : NEW_LINE INDENT result = 1 + LIP ( dp , mat , n , m , x + 1 , y ) NEW_LINE DEDENT if ( y + 1 < m and mat [ x ] [ y ] < mat [ x ] [ y + 1 ] ) : NEW_LINE INDENT result = max ( result , 1 + LIP ( dp , mat , n , m , x , y + 1 ) ) NEW_LINE DEDENT dp [ x ] [ y ] = result NEW_LINE DEDENT return dp [ x ] [ y ] NEW_LINE DEDENT def wrapper ( mat , n , m ) : NEW_LINE INDENT dp = [ [ - 1 for i in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE return LIP ( dp , mat , n , m , 0 , 0 ) NEW_LINE DEDENT mat = [ [ 1 , 2 , 3 , 4 ] , [ 2 , 2 , 3 , 4 ] , [ 3 , 2 , 3 , 4 ] , [ 4 , 5 , 6 , 7 ] ] NEW_LINE n = 4 NEW_LINE m = 4 NEW_LINE print ( wrapper ( mat , n , m ) ) NEW_LINE",
    "ideal_answer": "Longest Increasing Path in Matrix",
    "generated_answer": "This code prints out two arrays with even and odd numbers respectively"
  },
  {
    "code": "def countPaths ( n , m ) : NEW_LINE INDENT if ( n == 0 or m == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) NEW_LINE DEDENT n = 3 NEW_LINE m = 2 NEW_LINE print ( \" ▁ Number ▁ of ▁ Paths ▁ \" , countPaths ( n , m ) ) NEW_LINE",
    "ideal_answer": "Counts paths from a point to reach Origin",
    "generated_answer": "This code flips bits that are equal in two numbers"
  },
  {
    "code": "MAX = 100 NEW_LINE def getMaxGold ( gold , m , n ) : NEW_LINE INDENT goldTable = [ [ 0 for i in range ( n ) ] for j in range ( m ) ] NEW_LINE for col in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT for row in range ( m ) : NEW_LINE INDENT if ( col == n - 1 ) : NEW_LINE INDENT right = 0 NEW_LINE DEDENT else : NEW_LINE INDENT right = goldTable [ row ] [ col + 1 ] NEW_LINE DEDENT if ( row == 0 or col == n - 1 ) : NEW_LINE INDENT right_up = 0 NEW_LINE DEDENT else : NEW_LINE INDENT right_up = goldTable [ row - 1 ] [ col + 1 ] NEW_LINE DEDENT if ( row == m - 1 or col == n - 1 ) : NEW_LINE INDENT right_down = 0 NEW_LINE DEDENT else : NEW_LINE INDENT right_down = goldTable [ row + 1 ] [ col + 1 ] NEW_LINE DEDENT goldTable [ row ] [ col ] = gold [ row ] [ col ] + max ( right , right_up , right_down ) NEW_LINE DEDENT DEDENT res = goldTable [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , m ) : NEW_LINE INDENT res = max ( res , goldTable [ i ] [ 0 ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT gold = [ [ 1 , 3 , 1 , 5 ] , [ 2 , 2 , 4 , 1 ] , [ 5 , 0 , 2 , 3 ] , [ 0 , 6 , 1 , 2 ] ] NEW_LINE m = 4 NEW_LINE n = 4 NEW_LINE print ( getMaxGold ( gold , m , n ) ) NEW_LINE",
    "ideal_answer": "Gold Mine Problem",
    "generated_answer": "This code returns the distinct sums from one to n"
  },
  {
    "code": "M = 100 NEW_LINE def minAdjustmentCost ( A , n , target ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( M + 1 ) ] for i in range ( n ) ] NEW_LINE for j in range ( M + 1 ) : NEW_LINE INDENT dp [ 0 ] [ j ] = abs ( j - A [ 0 ] ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( M + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 100000000 NEW_LINE for k in range ( max ( j - target , 0 ) , min ( M , j + target ) + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + abs ( A [ i ] - j ) ) NEW_LINE DEDENT DEDENT DEDENT res = 10000000 NEW_LINE for j in range ( M + 1 ) : NEW_LINE INDENT res = min ( res , dp [ n - 1 ] [ j ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT arr = [ 55 , 77 , 52 , 61 , 39 , 6 , 25 , 60 , 49 , 47 ] NEW_LINE n = len ( arr ) NEW_LINE target = 10 NEW_LINE print ( \" Minimum ▁ adjustment ▁ cost ▁ is \" , minAdjustmentCost ( arr , n , target ) , sep = ' ▁ ' ) NEW_LINE",
    "ideal_answer": "Find minimum adjustment cost of an array",
    "generated_answer": "This code counts substrings with all single digits"
  },
  {
    "code": "def totalCombination ( L , R ) : NEW_LINE INDENT count = 0 NEW_LINE K = R - L NEW_LINE if ( K < L ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = K - L NEW_LINE count = ( ( ans + 1 ) * ( ans + 2 ) ) // 2 NEW_LINE return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L , R = 2 , 6 NEW_LINE print ( totalCombination ( L , R ) ) NEW_LINE DEDENT",
    "ideal_answer": "Count triplets from a given range having sum of two numbers of a triplet equal to the third number",
    "generated_answer": "This code returns integer after flipping bits"
  },
  {
    "code": "def printArrays ( n ) : NEW_LINE INDENT A , B = [ ] , [ ] ; NEW_LINE for i in range ( 1 , 2 * n + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT A . append ( i ) ; NEW_LINE DEDENT else : NEW_LINE INDENT B . append ( i ) ; NEW_LINE DEDENT DEDENT print ( \" { ▁ \" , end = \" \" ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( A [ i ] , end = \" \" ) ; NEW_LINE if ( i != n - 1 ) : NEW_LINE INDENT print ( \" , ▁ \" , end = \" \" ) ; NEW_LINE DEDENT DEDENT print ( \" } \" ) ; NEW_LINE print ( \" { ▁ \" , end = \" \" ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( B [ i ] , end = \" \" ) ; NEW_LINE if ( i != n - 1 ) : NEW_LINE INDENT print ( \" , \" , end = \" ▁ \" ) ; NEW_LINE DEDENT DEDENT print ( \" ▁ } \" , end = \" \" ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 5 ; NEW_LINE printArrays ( N ) ; NEW_LINE DEDENT",
    "ideal_answer": "Construct two N",
    "generated_answer": "This code encrypts sequence based on some conditions"
  },
  {
    "code": "def flipBitsOfAandB ( A , B ) : NEW_LINE INDENT for i in range ( 0 , 32 ) : NEW_LINE INDENT if ( ( A & ( 1 << i ) ) and ( B & ( 1 << i ) ) ) : NEW_LINE INDENT A = A ^ ( 1 << i ) NEW_LINE B = B ^ ( 1 << i ) NEW_LINE DEDENT DEDENT print ( A , B ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = 7 NEW_LINE B = 4 NEW_LINE flipBitsOfAandB ( A , B ) NEW_LINE DEDENT",
    "ideal_answer": "Numbers formed by flipping common set bits in two given integers",
    "generated_answer": "This code calculates strings with certain properties"
  },
  {
    "code": "def findDistinctSums ( N ) : NEW_LINE INDENT return ( 2 * N - 1 ) NEW_LINE DEDENT N = 3 NEW_LINE print ( findDistinctSums ( N ) ) NEW_LINE",
    "ideal_answer": "Count of distinct pair sum between two 1 to N value Arrays",
    "generated_answer": "This code demonstrates removal of all occurrences of a character"
  },
  {
    "code": "def countSubstrings ( str ) : NEW_LINE INDENT freq = [ 0 ] * 3 NEW_LINE count = 0 NEW_LINE i = 0 NEW_LINE for j in range ( 0 , len ( str ) ) : NEW_LINE INDENT freq [ ord ( str [ j ] ) - ord ( '0' ) ] += 1 NEW_LINE while ( freq [ 0 ] > 0 and freq [ 1 ] > 0 and freq [ 2 ] > 0 ) : NEW_LINE INDENT i += 1 NEW_LINE freq [ ord ( str [ i ] ) - ord ( '0' ) ] -= 1 NEW_LINE DEDENT count += i NEW_LINE DEDENT return count NEW_LINE DEDENT str = \"00021\" NEW_LINE count = countSubstrings ( str ) NEW_LINE print ( count ) NEW_LINE",
    "ideal_answer": "Count of substrings from given Ternary strings containing characters at least once",
    "generated_answer": "This code finds maximum  possible time satisfying given conditions"
  },
  {
    "code": "def minFlips ( st ) : NEW_LINE INDENT count = 0 NEW_LINE if ( len ( st ) <= 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( len ( st ) - 2 ) : NEW_LINE INDENT if ( st [ i ] == st [ i + 1 ] and st [ i + 2 ] == st [ i + 1 ] ) : NEW_LINE INDENT i = i + 3 NEW_LINE count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \"0011101\" NEW_LINE print ( minFlips ( S ) ) NEW_LINE DEDENT",
    "ideal_answer": "Minimum flips to remove any consecutive 3 0 s or 1 s in given Binary string",
    "generated_answer": "This function aims to check a boolean based on given conditions"
  },
  {
    "code": "def convertToHex ( num ) : NEW_LINE INDENT temp = \" \" NEW_LINE while ( num != 0 ) : NEW_LINE INDENT rem = num % 16 NEW_LINE c = 0 NEW_LINE if ( rem < 10 ) : NEW_LINE INDENT c = rem + 48 NEW_LINE DEDENT else : NEW_LINE INDENT c = rem + 87 NEW_LINE DEDENT temp += chr ( c ) NEW_LINE num = num // 16 NEW_LINE DEDENT return temp NEW_LINE DEDENT def encryptString ( S , N ) : NEW_LINE INDENT ans = \" \" NEW_LINE for i in range ( N ) : NEW_LINE INDENT ch = S [ i ] NEW_LINE count = 0 NEW_LINE while ( i < N and S [ i ] == ch ) : NEW_LINE INDENT count += 1 NEW_LINE i += 1 NEW_LINE DEDENT i -= 1 NEW_LINE hex = convertToHex ( count ) NEW_LINE ans += ch NEW_LINE ans += hex NEW_LINE DEDENT ans = ans [ : : - 1 ] NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = \" abc \" NEW_LINE N = len ( S ) NEW_LINE print ( encryptString ( S , N ) ) NEW_LINE DEDENT",
    "ideal_answer": "Encrypt the string",
    "generated_answer": "This code calculates the number of valid words for each puzzle"
  },
  {
    "code": "def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res //= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT def countOfString ( N ) : NEW_LINE INDENT Stotal = pow ( 2 , N ) NEW_LINE Sequal = 0 NEW_LINE if ( N % 2 == 0 ) : NEW_LINE INDENT Sequal = binomialCoeff ( N , N // 2 ) NEW_LINE DEDENT S1 = ( Stotal - Sequal ) // 2 NEW_LINE return S1 NEW_LINE DEDENT N = 3 NEW_LINE print ( countOfString ( N ) ) NEW_LINE",
    "ideal_answer": "Count of Binary Strings of length N such that frequency of 1 ' s ▁ exceeds ▁ frequency ▁ of ▁ 0' s",
    "generated_answer": "This code flips bits in a certain pattern"
  },
  {
    "code": "def removeCharRecursive ( str , X ) : NEW_LINE INDENT if ( len ( str ) == 0 ) : NEW_LINE INDENT return \" \" NEW_LINE DEDENT if ( str [ 0 ] == X ) : NEW_LINE INDENT return removeCharRecursive ( str [ 1 : ] , X ) NEW_LINE DEDENT return str [ 0 ] + removeCharRecursive ( str [ 1 : ] , X ) NEW_LINE DEDENT str = \" geeksforgeeks \" NEW_LINE X = ' e ' NEW_LINE str = removeCharRecursive ( str , X ) NEW_LINE print ( str ) NEW_LINE",
    "ideal_answer": "Remove all occurrences of a character in a string",
    "generated_answer": "This code prints the uppercase and lowercase letters in a sentence separated"
  },
  {
    "code": "def isValid ( a1 , a2 , strr , flag ) : NEW_LINE INDENT v1 , v2 = 0 , 0 NEW_LINE if ( flag == 0 ) : NEW_LINE INDENT v1 = strr [ 4 ] NEW_LINE v2 = strr [ 3 ] NEW_LINE DEDENT else : NEW_LINE INDENT v1 = strr [ 1 ] NEW_LINE v2 = strr [ 0 ] NEW_LINE DEDENT if ( v1 != a1 and v1 != ' ? ' ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( v2 != a2 and v2 != ' ? ' ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def inRange ( hh , mm , L , R ) : NEW_LINE INDENT a = abs ( hh - mm ) NEW_LINE if ( a < L or a > R ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def displayTime ( hh , mm ) : NEW_LINE INDENT if ( hh > 10 ) : NEW_LINE INDENT print ( hh , end = \" : \" ) NEW_LINE DEDENT elif ( hh < 10 ) : NEW_LINE INDENT print ( \"0\" , hh , end = \" : \" ) NEW_LINE DEDENT if ( mm > 10 ) : NEW_LINE INDENT print ( mm ) NEW_LINE DEDENT elif ( mm < 10 ) : NEW_LINE INDENT print ( \"0\" , mm ) NEW_LINE DEDENT DEDENT def maximumTimeWithDifferenceInRange ( strr , L , R ) : NEW_LINE INDENT i , j = 0 , 0 NEW_LINE h1 , h2 , m1 , m2 = 0 , 0 , 0 , 0 NEW_LINE for i in range ( 23 , - 1 , - 1 ) : NEW_LINE INDENT h1 = i % 10 NEW_LINE h2 = i // 10 NEW_LINE if ( not isValid ( chr ( h1 ) , chr ( h2 ) , strr , 1 ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( 59 , - 1 , - 1 ) : NEW_LINE INDENT m1 = j % 10 NEW_LINE m2 = j // 10 NEW_LINE if ( not isValid ( chr ( m1 ) , chr ( m2 ) , strr , 0 ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( inRange ( i , j , L , R ) ) : NEW_LINE INDENT displayTime ( i , j ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT if ( inRange ( i , j , L , R ) ) : NEW_LINE INDENT displayTime ( i , j ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT timeValue = \" ? ? : ? ? \" NEW_LINE L = 20 NEW_LINE R = 39 NEW_LINE maximumTimeWithDifferenceInRange ( timeValue , L , R ) NEW_LINE",
    "ideal_answer": "Maximum time such that absolute difference between hour and minute lies in given range",
    "generated_answer": "The amount of character 'a' in a repeated string is calculated"
  },
  {
    "code": "def check ( s , n ) : NEW_LINE INDENT st = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( len ( st ) != 0 and st [ len ( st ) - 1 ] == s [ i ] ) : NEW_LINE INDENT st . pop ( ) ; NEW_LINE DEDENT else : NEW_LINE INDENT st . append ( s [ i ] ) ; NEW_LINE DEDENT DEDENT if ( len ( st ) == 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT str = \" aanncddc \" ; NEW_LINE n = len ( str ) NEW_LINE if ( check ( str , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
    "ideal_answer": "Check if a string can be split into even length palindromic substrings",
    "generated_answer": "This code counts element frrequencies within limit"
  },
  {
    "code": "from collections import defaultdict NEW_LINE def findNumOfValidWords ( w , p ) : NEW_LINE INDENT m = defaultdict ( int ) NEW_LINE res = [ ] NEW_LINE for s in w : NEW_LINE INDENT val = 0 NEW_LINE for c in s : NEW_LINE INDENT val = val | ( 1 << ( ord ( c ) - ord ( ' a ' ) ) ) NEW_LINE DEDENT m [ val ] += 1 NEW_LINE DEDENT for s in p : NEW_LINE INDENT val = 0 NEW_LINE for c in s : NEW_LINE INDENT val = val | ( 1 << ( ord ( c ) - ord ( ' a ' ) ) ) NEW_LINE DEDENT temp = val NEW_LINE first = ord ( s [ 0 ] ) - ord ( ' a ' ) NEW_LINE count = 0 NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT if ( ( ( temp >> first ) & 1 ) == 1 ) : NEW_LINE INDENT if ( temp in m ) : NEW_LINE INDENT count += m [ temp ] NEW_LINE DEDENT DEDENT temp = ( temp - 1 ) & val NEW_LINE DEDENT res . append ( count ) NEW_LINE DEDENT for it in res : NEW_LINE INDENT print ( it ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr1 = [ \" aaaa \" , \" asas \" , \" able \" , \" ability \" , \" actt \" , \" actor \" , \" access \" ] NEW_LINE arr2 = [ \" aboveyz \" , \" abrodyz \" , \" absolute \" , \" absoryz \" , \" actresz \" , \" gaswxyz \" ] NEW_LINE findNumOfValidWords ( arr1 , arr2 ) NEW_LINE DEDENT",
    "ideal_answer": "Number of strings in two array satisfy the given conditions",
    "generated_answer": "This determines if m consecutive zero or one occur in the given string"
  },
  {
    "code": "def flip ( s ) : NEW_LINE INDENT s = list ( s ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT while ( s [ i ] == '0' ) : NEW_LINE INDENT s [ i ] = '1' NEW_LINE i += 1 NEW_LINE DEDENT s = ' ' . join ( map ( str , s ) ) NEW_LINE return s NEW_LINE DEDENT DEDENT DEDENT s = \"100010001\" NEW_LINE print ( flip ( s ) ) NEW_LINE",
    "ideal_answer": "Maximize the decimal equivalent by flipping only a contiguous set of 0 s",
    "generated_answer": "This code finds the product of elements at the Kth level of a tree"
  },
  {
    "code": "def getOrgString ( s ) : NEW_LINE INDENT print ( s [ 0 ] , end = \" \" ) NEW_LINE i = 1 NEW_LINE while ( i < len ( s ) ) : NEW_LINE INDENT if ( ord ( s [ i ] ) >= ord ( ' A ' ) and ord ( s [ i ] ) <= ord ( ' Z ' ) ) : NEW_LINE INDENT print ( \" ▁ \" , s [ i ] . lower ( ) , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s [ i ] , end = \" \" ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT s = \" ILoveGeeksForGeeks \" NEW_LINE getOrgString ( s ) NEW_LINE",
    "ideal_answer": "Sentence Case of a given Camel cased string",
    "generated_answer": "This code finds non duplicate elements in a matrix"
  },
  {
    "code": "' NEW_LINE def countChar ( str , x ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == x ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT n = 10 NEW_LINE repetitions = n // len ( str ) NEW_LINE count = count * repetitions NEW_LINE l = n % len ( str ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( str [ i ] == x ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT str = \" abcac \" NEW_LINE print ( countChar ( str , ' a ' ) ) NEW_LINE",
    "ideal_answer": "Count occurrences of a character in a repeated string",
    "generated_answer": "This code checks whether a given ISBN number is valid or not"
  },
  {
    "code": "def countFreq ( arr , n , limit ) : NEW_LINE INDENT count = [ 0 for i in range ( limit + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( limit + 1 ) : NEW_LINE INDENT if ( count [ i ] > 0 ) : NEW_LINE INDENT print ( i , count [ i ] ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 5 , 5 , 6 , 6 , 5 , 6 , 1 , 2 , 3 , 10 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE limit = 10 NEW_LINE countFreq ( arr , n , limit ) NEW_LINE",
    "ideal_answer": "Frequency Measuring Techniques for Competitive Programming",
    "generated_answer": "This code reverses the vowels in a given string"
  },
  {
    "code": "def check ( s , m ) : NEW_LINE INDENT l = len ( s ) ; NEW_LINE c1 = 0 ; NEW_LINE c2 = 0 ; NEW_LINE for i in range ( 0 , l - 1 ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT c2 = 0 ; NEW_LINE c1 = c1 + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT c1 = 0 ; NEW_LINE c2 = c2 + 1 ; NEW_LINE DEDENT if ( c1 == m or c2 == m ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT s = \"001001\" ; NEW_LINE m = 2 ; NEW_LINE if ( check ( s , m ) ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT",
    "ideal_answer": "Check if a string has m consecutive 1 ' s ▁ or ▁ 0' s",
    "generated_answer": "This prints the first letter of each word in sentence"
  },
  {
    "code": "def productAtKthLevel ( tree , k ) : NEW_LINE INDENT level = - 1 NEW_LINE product = 1 NEW_LINE n = len ( tree ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( tree [ i ] == ' ( ' ) : NEW_LINE INDENT level += 1 NEW_LINE DEDENT elif ( tree [ i ] == ' ) ' ) : NEW_LINE INDENT level -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( level == k ) : NEW_LINE INDENT product *= ( int ( tree [ i ] ) - int ( '0' ) ) NEW_LINE DEDENT DEDENT DEDENT return product NEW_LINE DEDENT tree = \" ( 0(5(6 ( ) ( ) ) ( 4 ( ) (9 ( ) ( ) ) ) ) ( 7(1 ( ) ( ) ) ( 3 ( ) ( ) ) ) ) \" NEW_LINE k = 2 NEW_LINE print ( productAtKthLevel ( tree , k ) ) NEW_LINE",
    "ideal_answer": "Product of nodes at k",
    "generated_answer": "This code calculates unique paths using DFS and backtracking"
  },
  {
    "code": "def findDuplicates ( a , n , m ) : NEW_LINE INDENT isPresent = [ [ False for i in range ( n ) ] for j in range ( m ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT for k in range ( n ) : NEW_LINE INDENT if i != k and a [ i ] [ j ] == a [ k ] [ j ] : NEW_LINE INDENT isPresent [ i ] [ j ] = True NEW_LINE isPresent [ k ] [ j ] = True NEW_LINE DEDENT DEDENT for k in range ( m ) : NEW_LINE INDENT if j != k and a [ i ] [ j ] == a [ i ] [ k ] : NEW_LINE INDENT isPresent [ i ] [ j ] = True NEW_LINE isPresent [ i ] [ k ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if not isPresent [ i ] [ j ] : NEW_LINE INDENT print ( a [ i ] [ j ] , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 2 NEW_LINE m = 2 NEW_LINE a = [ \" zx \" , \" xz \" ] NEW_LINE findDuplicates ( a , n , m ) NEW_LINE DEDENT",
    "ideal_answer": "Removing row or column wise duplicates from matrix of characters",
    "generated_answer": "This code counts pairs based on relationship between array elements"
  },
  {
    "code": "def isValidISBN ( isbn ) : NEW_LINE INDENT if len ( isbn ) != 10 : NEW_LINE INDENT return False NEW_LINE DEDENT _sum = 0 NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT if 0 <= int ( isbn [ i ] ) <= 9 : NEW_LINE INDENT _sum += int ( isbn [ i ] ) * ( 10 - i ) NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if ( isbn [ 9 ] != ' X ' and 0 <= int ( isbn [ 9 ] ) <= 9 ) : NEW_LINE INDENT return False NEW_LINE DEDENT _sum += 10 if isbn [ 9 ] == ' X ' else int ( isbn [ 9 ] ) NEW_LINE return ( _sum % 11 == 0 ) NEW_LINE DEDENT isbn = \"007462542X \" NEW_LINE if isValidISBN ( isbn ) : NEW_LINE INDENT print ( ' Valid ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Invalid \" ) NEW_LINE DEDENT",
    "ideal_answer": "Program to check for ISBN",
    "generated_answer": "The code calculates the area of ​​the square with side S"
  },
  {
    "code": "def isVowel ( c ) : NEW_LINE INDENT if ( c == ' a ' or c == ' A ' or c == ' e ' or c == ' E ' or c == ' i ' or c == ' I ' or c == ' o ' or c == ' O ' or c == ' u ' or c == ' U ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def reverserVowel ( string ) : NEW_LINE INDENT j = 0 NEW_LINE vowel = [ 0 ] * len ( string ) NEW_LINE string = list ( string ) NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if isVowel ( string [ i ] ) : NEW_LINE INDENT vowel [ j ] = string [ i ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT for i in range ( len ( string ) ) : NEW_LINE INDENT if isVowel ( string [ i ] ) : NEW_LINE INDENT j -= 1 NEW_LINE string [ i ] = vowel [ j ] NEW_LINE DEDENT DEDENT return ' ' . join ( string ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" hello ▁ world \" NEW_LINE print ( reverserVowel ( string ) ) NEW_LINE DEDENT",
    "ideal_answer": "Reverse vowels in a given string",
    "generated_answer": "This code calculates intersection point max using other two parameters"
  },
  {
    "code": "def firstLetterWord ( str ) : NEW_LINE INDENT result = \" \" NEW_LINE v = True NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == ' ▁ ' ) : NEW_LINE INDENT v = True NEW_LINE DEDENT elif ( str [ i ] != ' ▁ ' and v == True ) : NEW_LINE INDENT result += ( str [ i ] ) NEW_LINE v = False NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeks ▁ for ▁ geeks \" NEW_LINE print ( firstLetterWord ( str ) ) NEW_LINE DEDENT",
    "ideal_answer": "String containing first letter of every word in a given string with spaces",
    "generated_answer": "The code computes the value of the icosihenagonal number for input n"
  },
  {
    "code": "def dfs ( i , j , grid , vis , ans , z , z_count ) : NEW_LINE INDENT n = len ( grid ) NEW_LINE m = len ( grid [ 0 ] ) NEW_LINE vis [ i ] [ j ] = 1 NEW_LINE if ( grid [ i ] [ j ] == 0 ) : NEW_LINE INDENT z += 1 NEW_LINE DEDENT if ( grid [ i ] [ j ] == 2 ) : NEW_LINE INDENT if ( z == z_count ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT vis [ i ] [ j ] = 0 NEW_LINE return grid , vis , ans NEW_LINE DEDENT if ( i >= 1 and not vis [ i - 1 ] [ j ] and grid [ i - 1 ] [ j ] != - 1 ) : NEW_LINE INDENT grid , vis , ans = dfs ( i - 1 , j , grid , vis , ans , z , z_count ) NEW_LINE DEDENT if ( i < n - 1 and not vis [ i + 1 ] [ j ] and grid [ i + 1 ] [ j ] != - 1 ) : NEW_LINE INDENT grid , vis , ans = dfs ( i + 1 , j , grid , vis , ans , z , z_count ) NEW_LINE DEDENT if ( j >= 1 and not vis [ i ] [ j - 1 ] and grid [ i ] [ j - 1 ] != - 1 ) : NEW_LINE INDENT grid , vis , ans = dfs ( i , j - 1 , grid , vis , ans , z , z_count ) NEW_LINE DEDENT if ( j < m - 1 and not vis [ i ] [ j + 1 ] and grid [ i ] [ j + 1 ] != - 1 ) : NEW_LINE INDENT grid , vis , ans = dfs ( i , j + 1 , grid , vis , ans , z , z_count ) NEW_LINE DEDENT vis [ i ] [ j ] = 0 NEW_LINE return grid , vis , ans NEW_LINE DEDENT def uniquePaths ( grid ) : NEW_LINE INDENT z_count = 0 NEW_LINE n = len ( grid ) NEW_LINE m = len ( grid [ 0 ] ) NEW_LINE ans = 0 NEW_LINE vis = [ [ 0 for j in range ( m ) ] for i in range ( n ) ] NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if grid [ i ] [ j ] == 0 : NEW_LINE INDENT z_count += 1 NEW_LINE DEDENT elif ( grid [ i ] [ j ] == 1 ) : NEW_LINE INDENT x = i NEW_LINE y = j NEW_LINE DEDENT DEDENT DEDENT grid , vis , ans = dfs ( x , y , grid , vis , ans , 0 , z_count ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT grid = [ [ 1 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 2 , - 1 ] ] NEW_LINE print ( uniquePaths ( grid ) ) NEW_LINE DEDENT",
    "ideal_answer": "Unique paths covering every non",
    "generated_answer": "finds the centroid of a polygon given its vertices"
  },
  {
    "code": "def numPairs ( a , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] = abs ( a [ i ] ) NEW_LINE DEDENT a . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT index = 0 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( 2 * a [ i ] >= a [ j - 1 ] and 2 * a [ i ] < a [ j ] ) : NEW_LINE INDENT index = j NEW_LINE DEDENT DEDENT if index == 0 : NEW_LINE INDENT index = n NEW_LINE DEDENT ans += index - i - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT a = [ 3 , 6 ] NEW_LINE n = len ( a ) NEW_LINE print ( numPairs ( a , n ) ) NEW_LINE",
    "ideal_answer": "Count of unordered pairs ( x , y ) of Array which satisfy given equation",
    "generated_answer": "calculates angles in degrees with differences of 10 degrees between them"
  },
  {
    "code": "def areaOfSquare ( S ) : NEW_LINE INDENT area = S * S NEW_LINE return area NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = 5 NEW_LINE print ( areaOfSquare ( S ) ) NEW_LINE DEDENT",
    "ideal_answer": "Area of a Square",
    "generated_answer": "Calculates perpendicular distance using plain equations"
  },
  {
    "code": "def maxPointOfIntersection ( x , y ) : NEW_LINE INDENT k = y * ( y - 1 ) // 2 NEW_LINE k = k + x * ( 2 * y + x - 1 ) NEW_LINE return k NEW_LINE DEDENT x = 3 NEW_LINE y = 4 NEW_LINE print ( maxPointOfIntersection ( x , y ) ) NEW_LINE",
    "ideal_answer": "Maximum points of intersections possible among X circles and Y straight lines",
    "generated_answer": "this code calculates the number of possible necklaces"
  },
  {
    "code": "def Icosihenagonal_num ( n ) : NEW_LINE INDENT return ( 19 * n * n - 17 * n ) / 2 NEW_LINE DEDENT n = 3 NEW_LINE print ( int ( Icosihenagonal_num ( n ) ) ) NEW_LINE n = 10 NEW_LINE print ( int ( Icosihenagonal_num ( n ) ) ) NEW_LINE",
    "ideal_answer": "Icosihenagonal Number",
    "generated_answer": ""
  }
]