[
  {
    "code": "def minSum ( A , N ) : NEW_LINE INDENT mp = { } NEW_LINE sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += A [ i ] NEW_LINE if A [ i ] in mp : NEW_LINE INDENT mp [ A [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ A [ i ] ] = 1 NEW_LINE DEDENT DEDENT minSum = float ( ' inf ' ) NEW_LINE for it in mp : NEW_LINE INDENT minSum = min ( minSum , sum - ( it * mp [ it ] ) ) NEW_LINE DEDENT return minSum NEW_LINE DEDENT arr = [ 4 , 5 , 6 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE print ( minSum ( arr , N ) ) NEW_LINE",
    "summary": {
      "ideal": "Minimum sum possible by removing all occurrences of any array element",
      "generated": "Function to find minimal sum by removing duplicates from array",
      "metrics": {
        "bleu": 0.0,
        "rouge-1": 0.381,
        "rouge-2": 0.1053,
        "rouge-l": 0.381,
        "bertscore": {
          "precision": 0.9068,
          "recall": 0.9053,
          "f1": 0.9061
        }
      }
    },
    "query": [
      {
        "query1": "Python code to find minimum sum of array by removing one occurrence of any element",
        "metrics": {
          "bleu": 0.0,
          "rouge-1": 0.56,
          "rouge-2": 0.1667,
          "rouge-l": 0.48,
          "bertscore": {
            "precision": 0.9204,
            "recall": 0.936,
            "f1": 0.9282
          }
        }
      },
      {
        "query2": "Python code to find minimum sum after subtracting element counts",
        "metrics": {
          "bleu": 0.0,
          "rouge-1": 0.1905,
          "rouge-2": 0.0,
          "rouge-l": 0.1905,
          "bertscore": {
            "precision": 0.887,
            "recall": 0.8837,
            "f1": 0.8854
          }
        }
      },
      {
        "query3": "python function to find minimum sum of array after removing one element",
        "metrics": {
          "bleu": 0.0,
          "rouge-1": 0.4348,
          "rouge-2": 0.0,
          "rouge-l": 0.3478,
          "bertscore": {
            "precision": 0.9056,
            "recall": 0.9032,
            "f1": 0.9044
          }
        }
      }
    ]
  },
  {
    "code": "def maxAdjacent ( arr , N ) : NEW_LINE INDENT res = [ ] NEW_LINE for i in range ( 1 , N - 1 ) : NEW_LINE INDENT prev = arr [ 0 ] NEW_LINE maxi = - 1 * float ( ' inf ' ) NEW_LINE for j in range ( 1 , N ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT continue NEW_LINE DEDENT maxi = max ( maxi , abs ( arr [ j ] - prev ) ) NEW_LINE prev = arr [ j ] NEW_LINE DEDENT res . append ( maxi ) NEW_LINE DEDENT for x in res : NEW_LINE INDENT print ( x , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT arr = [ 1 , 3 , 4 , 7 , 8 ] NEW_LINE N = len ( arr ) NEW_LINE maxAdjacent ( arr , N ) NEW_LINE",
    "summary": {
      "ideal": "Maximum difference between a pair of adjacent elements by excluding every element once",
      "generated": "Function to find maximal adjacent differences in array",
      "metrics": {
        "bleu": 0.0,
        "rouge-1": 0.0952,
        "rouge-2": 0.0,
        "rouge-l": 0.0952,
        "bertscore": {
          "precision": 0.8864,
          "recall": 0.8668,
          "f1": 0.8765
        }
      }
    },
    "query": [
      {
        "query1": "python function to calculate maximum adjacent difference in array",
        "metrics": {
          "bleu": 0.0,
          "rouge-1": 0.1818,
          "rouge-2": 0.0,
          "rouge-l": 0.0909,
          "bertscore": {
            "precision": 0.8842,
            "recall": 0.8672,
            "f1": 0.8756
          }
        }
      },
      {
        "query2": "Python code to find maximum adjacent difference in array",
        "metrics": {
          "bleu": 0.0,
          "rouge-1": 0.1818,
          "rouge-2": 0.0,
          "rouge-l": 0.0909,
          "bertscore": {
            "precision": 0.8813,
            "recall": 0.8702,
            "f1": 0.8757
          }
        }
      },
      {
        "query3": "python function to find maximum adjacent difference in an array",
        "metrics": {
          "bleu": 0.0,
          "rouge-1": 0.1739,
          "rouge-2": 0.0,
          "rouge-l": 0.087,
          "bertscore": {
            "precision": 0.8858,
            "recall": 0.8717,
            "f1": 0.8787
          }
        }
      }
    ]
  },
  {
    "code": "def findSize ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( N == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT Size = 2 * findSize ( N // 2 ) + 1 NEW_LINE return Size NEW_LINE DEDENT def CountOnes ( N , L , R ) : NEW_LINE INDENT if ( L > R ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( N <= 1 ) : NEW_LINE INDENT return N NEW_LINE DEDENT ret = 0 NEW_LINE M = N // 2 NEW_LINE Siz_M = findSize ( M ) NEW_LINE if ( L <= Siz_M ) : NEW_LINE INDENT ret += CountOnes ( N // 2 , L , min ( Siz_M , R ) ) NEW_LINE DEDENT if ( L <= Siz_M + 1 and Siz_M + 1 <= R ) : NEW_LINE INDENT ret += N % 2 NEW_LINE DEDENT if ( Siz_M + 1 < R ) : NEW_LINE INDENT ret += CountOnes ( N // 2 , max ( 1 , L - Siz_M - 1 ) , R - Siz_M - 1 ) NEW_LINE DEDENT return ret NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 7 NEW_LINE L = 2 NEW_LINE R = 5 NEW_LINE print ( CountOnes ( N , L , R ) ) NEW_LINE DEDENT",
    "summary": {
      "ideal": "Count 1 s present in a range of indices [ L , R ] in a given array",
      "generated": "Recursive function to count ones in a specific range",
      "metrics": {
        "bleu": 0.0,
        "rouge-1": 0.24,
        "rouge-2": 0.0833,
        "rouge-l": 0.24,
        "bertscore": {
          "precision": 0.8671,
          "recall": 0.854,
          "f1": 0.8605
        }
      }
    },
    "query": [
      {
        "query1": "recursive function to count ones in binary representation between L and R",
        "metrics": {
          "bleu": 0.0,
          "rouge-1": 0.2143,
          "rouge-2": 0.0,
          "rouge-l": 0.2143,
          "bertscore": {
            "precision": 0.8681,
            "recall": 0.8638,
            "f1": 0.8659
          }
        }
      },
      {
        "query2": "Python code to count ones in binary representation of a number",
        "metrics": {
          "bleu": 0.0,
          "rouge-1": 0.2222,
          "rouge-2": 0.0,
          "rouge-l": 0.2222,
          "bertscore": {
            "precision": 0.8516,
            "recall": 0.8379,
            "f1": 0.8447
          }
        }
      },
      {
        "query3": "python function to count ones in a binary sequence using recursion",
        "metrics": {
          "bleu": 0.0,
          "rouge-1": 0.1481,
          "rouge-2": 0.0769,
          "rouge-l": 0.1481,
          "bertscore": {
            "precision": 0.8642,
            "recall": 0.8488,
            "f1": 0.8564
          }
        }
      }
    ]
  },
  {
    "code": "def prime ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i * i > n : NEW_LINE INDENT break NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def minDivisior ( n ) : NEW_LINE INDENT if ( prime ( n ) ) : NEW_LINE INDENT print ( 1 , n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i * i > n : NEW_LINE INDENT break NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT print ( n // i , n // i * ( i - 1 ) ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT N = 4 NEW_LINE minDivisior ( N ) NEW_LINE",
    "summary": {
      "ideal": "Find the pair ( a , b ) with minimum LCM such that their sum is equal to N",
      "generated": "Function to find minimal divisor and print result",
      "metrics": {
        "bleu": 0.0,
        "rouge-1": 0.0741,
        "rouge-2": 0.0,
        "rouge-l": 0.0741,
        "bertscore": {
          "precision": 0.8632,
          "recall": 0.8348,
          "f1": 0.8488
        }
      }
    },
    "query": [
      {
        "query1": "Python code to find minimum divisor and print result",
        "metrics": {
          "bleu": 0.0,
          "rouge-1": 0.1429,
          "rouge-2": 0.0,
          "rouge-l": 0.0714,
          "bertscore": {
            "precision": 0.8629,
            "recall": 0.8377,
            "f1": 0.8501
          }
        }
      },
      {
        "query2": "Python code to find minimum divisor with prime check",
        "metrics": {
          "bleu": 0.0,
          "rouge-1": 0.2143,
          "rouge-2": 0.0,
          "rouge-l": 0.0714,
          "bertscore": {
            "precision": 0.8624,
            "recall": 0.8368,
            "f1": 0.8494
          }
        }
      },
      {
        "query3": "python function to find minimum divisor and print result",
        "metrics": {
          "bleu": 0.0,
          "rouge-1": 0.1429,
          "rouge-2": 0.0,
          "rouge-l": 0.0714,
          "bertscore": {
            "precision": 0.8653,
            "recall": 0.8386,
            "f1": 0.8517
          }
        }
      }
    ]
  },
  {
    "code": "import sys NEW_LINE Landau = - sys . maxsize - 1 NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return ( a * b ) // gcd ( a , b ) NEW_LINE DEDENT def findLCM ( arr ) : NEW_LINE INDENT global Landau NEW_LINE nth_lcm = arr [ 0 ] NEW_LINE for i in range ( 1 , len ( arr ) ) : NEW_LINE INDENT nth_lcm = lcm ( nth_lcm , arr [ i ] ) NEW_LINE DEDENT Landau = max ( Landau , nth_lcm ) NEW_LINE DEDENT def findWays ( arr , i , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT findLCM ( arr ) NEW_LINE DEDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT arr . append ( j ) NEW_LINE findWays ( arr , j , n - j ) NEW_LINE arr . pop ( ) NEW_LINE DEDENT DEDENT def Landau_function ( n ) : NEW_LINE INDENT arr = [ ] NEW_LINE findWays ( arr , 1 , n ) NEW_LINE print ( Landau ) NEW_LINE DEDENT N = 4 NEW_LINE Landau_function ( N ) NEW_LINE",
    "summary": {
      "ideal": "Find Landau 's function for a given number N",
      "generated": "Function to find maximum LCM in Landau's function",
      "metrics": {
        "bleu": 0.0,
        "rouge-1": 0.1176,
        "rouge-2": 0.0,
        "rouge-l": 0.1176,
        "bertscore": {
          "precision": 0.8642,
          "recall": 0.8604,
          "f1": 0.8623
        }
      }
    },
    "query": [
      {
        "query1": "Python code to calculate LCM using partitions and Landau function",
        "metrics": {
          "bleu": 0.0,
          "rouge-1": 0.2105,
          "rouge-2": 0.0,
          "rouge-l": 0.2105,
          "bertscore": {
            "precision": 0.8584,
            "recall": 0.8526,
            "f1": 0.8555
          }
        }
      },
      {
        "query2": "Python code to compute Landau function for a number",
        "metrics": {
          "bleu": 0.0,
          "rouge-1": 0.5556,
          "rouge-2": 0.25,
          "rouge-l": 0.5556,
          "bertscore": {
            "precision": 0.9002,
            "recall": 0.8762,
            "f1": 0.888
          }
        }
      },
      {
        "query3": "python function to compute Landau's function for a given number",
        "metrics": {
          "bleu": 0.3928,
          "rouge-1": 0.5556,
          "rouge-2": 0.4706,
          "rouge-l": 0.5556,
          "bertscore": {
            "precision": 0.9271,
            "recall": 0.9134,
            "f1": 0.9202
          }
        }
      }
    ]
  },
  {
    "code": "def isPrime ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( ( n % 2 == 0 ) or ( n % 3 == 0 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( ( n % i == 0 ) or ( n % ( i + 2 ) == 0 ) ) : NEW_LINE INDENT return False ; NEW_LINE i += 6 NEW_LINE DEDENT DEDENT return true ; NEW_LINE DEDENT def checkExpression ( n ) : NEW_LINE INDENT if ( isPrime ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE checkExpression ( N ) NEW_LINE DEDENT",
    "summary": {
      "ideal": "Check if the remainder of N",
      "generated": "Check if a number is prime",
      "metrics": {
        "bleu": 0.0,
        "rouge-1": 0.3333,
        "rouge-2": 0.2,
        "rouge-l": 0.3333,
        "bertscore": {
          "precision": 0.8529,
          "recall": 0.8755,
          "f1": 0.864
        }
      }
    },
    "query": [
      {
        "query1": "Python code to check if a number is prime and print result",
        "metrics": {
          "bleu": 0.0,
          "rouge-1": 0.1111,
          "rouge-2": 0.0,
          "rouge-l": 0.1111,
          "bertscore": {
            "precision": 0.8313,
            "recall": 0.8606,
            "f1": 0.8457
          }
        }
      },
      {
        "query2": "Python code to check if a number is prime",
        "metrics": {
          "bleu": 0.0,
          "rouge-1": 0.1333,
          "rouge-2": 0.0,
          "rouge-l": 0.1333,
          "bertscore": {
            "precision": 0.8368,
            "recall": 0.8586,
            "f1": 0.8476
          }
        }
      },
      {
        "query3": "python function to check if a number is prime and print the result",
        "metrics": {
          "bleu": 0.0,
          "rouge-1": 0.2105,
          "rouge-2": 0.0,
          "rouge-l": 0.2105,
          "bertscore": {
            "precision": 0.8414,
            "recall": 0.8657,
            "f1": 0.8534
          }
        }
      }
    ]
  },
  {
    "code": "def checkArray ( n , k , arr ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if ( cnt >= k and cnt % 2 == k % 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 3 , 4 , 7 , 5 , 3 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE k = 4 NEW_LINE if ( checkArray ( n , k , arr ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
    "summary": {
      "ideal": "Check if it is possible to split given Array into K odd",
      "generated": "Check if array has at least k odd elements with matching parity",
      "metrics": {
        "bleu": 0.0,
        "rouge-1": 0.25,
        "rouge-2": 0.0909,
        "rouge-l": 0.25,
        "bertscore": {
          "precision": 0.8496,
          "recall": 0.8604,
          "f1": 0.855
        }
      }
    },
    "query": [
      {
        "query1": "Python code to check if array has at least K odd numbers with matching parity",
        "metrics": {
          "bleu": 0.0,
          "rouge-1": 0.2963,
          "rouge-2": 0.08,
          "rouge-l": 0.2222,
          "bertscore": {
            "precision": 0.8624,
            "recall": 0.8788,
            "f1": 0.8705
          }
        }
      },
      {
        "query2": "Python code to check if array has enough odd elements",
        "metrics": {
          "bleu": 0.0,
          "rouge-1": 0.2727,
          "rouge-2": 0.0,
          "rouge-l": 0.1818,
          "bertscore": {
            "precision": 0.8711,
            "recall": 0.8618,
            "f1": 0.8664
          }
        }
      },
      {
        "query3": "python function to check if an array has at least k odd elements",
        "metrics": {
          "bleu": 0.0,
          "rouge-1": 0.24,
          "rouge-2": 0.0,
          "rouge-l": 0.16,
          "bertscore": {
            "precision": 0.8704,
            "recall": 0.8779,
            "f1": 0.8741
          }
        }
      }
    ]
  },
  {
    "code": "from math import * NEW_LINE def func ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE maxx = 0 NEW_LINE freq = [ 0 ] * 100005 NEW_LINE temp = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE freq [ temp ] += 1 NEW_LINE maxx = max ( maxx , temp ) NEW_LINE DEDENT for i in range ( 1 , maxx + 1 ) : NEW_LINE INDENT freq [ i ] += freq [ i - 1 ] NEW_LINE DEDENT for i in range ( 1 , maxx + 1 ) : NEW_LINE INDENT if ( freq [ i ] ) : NEW_LINE INDENT value = 0 NEW_LINE cur = ceil ( 0.5 * i ) - 1.0 NEW_LINE j = 1.5 NEW_LINE while ( 1 ) : NEW_LINE INDENT val = min ( maxx , ( ceil ( i * j ) - 1.0 ) ) NEW_LINE times = ( freq [ i ] - freq [ i - 1 ] ) NEW_LINE con = j - 0.5 NEW_LINE ans += times * con * ( freq [ int ( val ) ] - freq [ int ( cur ) ] ) NEW_LINE cur = val NEW_LINE if ( val == maxx ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT DEDENT return int ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( func ( arr , n ) ) NEW_LINE DEDENT",
    "summary": {
      "ideal": "Sum of division of the possible pairs for the given Array",
      "generated": "Function to compute a complex mathematical result from array",
      "metrics": {
        "bleu": 0,
        "rouge-1": 0.0,
        "rouge-2": 0.0,
        "rouge-l": 0.0,
        "bertscore": {
          "precision": 0.869,
          "recall": 0.8617,
          "f1": 0.8653
        }
      }
    },
    "query": [
      {
        "query1": "Python code to compute a mathematical operation on array elements",
        "metrics": {
          "bleu": 0,
          "rouge-1": 0.0,
          "rouge-2": 0.0,
          "rouge-l": 0.0,
          "bertscore": {
            "precision": 0.877,
            "recall": 0.8686,
            "f1": 0.8728
          }
        }
      },
      {
        "query2": "Python code to calculate function value using frequency counts",
        "metrics": {
          "bleu": 0,
          "rouge-1": 0.0,
          "rouge-2": 0.0,
          "rouge-l": 0.0,
          "bertscore": {
            "precision": 0.8567,
            "recall": 0.8504,
            "f1": 0.8535
          }
        }
      },
      {
        "query3": "python function to calculate a mathematical expression on array elements",
        "metrics": {
          "bleu": 0,
          "rouge-1": 0.0,
          "rouge-2": 0.0,
          "rouge-l": 0.0,
          "bertscore": {
            "precision": 0.8764,
            "recall": 0.8638,
            "f1": 0.8701
          }
        }
      }
    ]
  },
  {
    "code": "def insert_element ( a , n ) : NEW_LINE INDENT Xor = 0 NEW_LINE Sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Xor ^= a [ i ] NEW_LINE Sum += a [ i ] NEW_LINE DEDENT if ( Sum == 2 * Xor ) : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT if ( Xor == 0 ) : NEW_LINE INDENT print ( 1 ) NEW_LINE print ( Sum ) NEW_LINE return NEW_LINE DEDENT num1 = Sum + Xor NEW_LINE num2 = Xor NEW_LINE print ( 2 ) NEW_LINE print ( num1 , num2 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE insert_element ( a , n ) NEW_LINE DEDENT",
    "summary": {
      "ideal": "Count of elements to be inserted to make Array sum twice the XOR of Array",
      "generated": "Function to insert elements based on XOR and sum conditions",
      "metrics": {
        "bleu": 0.0,
        "rouge-1": 0.3636,
        "rouge-2": 0.0,
        "rouge-l": 0.1818,
        "bertscore": {
          "precision": 0.9073,
          "recall": 0.8914,
          "f1": 0.8993
        }
      }
    },
    "query": [
      {
        "query1": "Python code to insert elements to make sum equal to twice XOR of array",
        "metrics": {
          "bleu": 0.0,
          "rouge-1": 0.5833,
          "rouge-2": 0.2222,
          "rouge-l": 0.5,
          "bertscore": {
            "precision": 0.9326,
            "recall": 0.9367,
            "f1": 0.9346
          }
        }
      },
      {
        "query2": "Python code to insert elements based on XOR condition",
        "metrics": {
          "bleu": 0.0,
          "rouge-1": 0.2857,
          "rouge-2": 0.0,
          "rouge-l": 0.1905,
          "bertscore": {
            "precision": 0.9023,
            "recall": 0.8854,
            "f1": 0.8938
          }
        }
      },
      {
        "query3": "python function to insert elements into an array based on XOR and sum conditions",
        "metrics": {
          "bleu": 0.0,
          "rouge-1": 0.3077,
          "rouge-2": 0.0,
          "rouge-l": 0.1538,
          "bertscore": {
            "precision": 0.8885,
            "recall": 0.8942,
            "f1": 0.8914
          }
        }
      }
    ]
  },
  {
    "code": "def checkSolution ( a , b , c ) : NEW_LINE INDENT if ( a == c ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT a = 2 ; b = 0 ; c = 2 ; NEW_LINE checkSolution ( a , b , c ) ; NEW_LINE",
    "summary": {
      "ideal": "Check if roots of a Quadratic Equation are reciprocal of each other or not",
      "generated": "Check if a equals c without considering b",
      "metrics": {
        "bleu": 0.0,
        "rouge-1": 0.2857,
        "rouge-2": 0.1,
        "rouge-l": 0.2857,
        "bertscore": {
          "precision": 0.866,
          "recall": 0.8265,
          "f1": 0.8458
        }
      }
    },
    "query": [
      {
        "query1": "python function to check if a equals c",
        "metrics": {
          "bleu": 0.0,
          "rouge-1": 0.1905,
          "rouge-2": 0.0,
          "rouge-l": 0.1905,
          "bertscore": {
            "precision": 0.8651,
            "recall": 0.8264,
            "f1": 0.8453
          }
        }
      },
      {
        "query2": "Python code to check if a solution exists",
        "metrics": {
          "bleu": 0.0,
          "rouge-1": 0.1905,
          "rouge-2": 0.0,
          "rouge-l": 0.1905,
          "bertscore": {
            "precision": 0.8747,
            "recall": 0.8392,
            "f1": 0.8566
          }
        }
      },
      {
        "query3": "python function to check if a equals c and print the result",
        "metrics": {
          "bleu": 0.0,
          "rouge-1": 0.16,
          "rouge-2": 0.0,
          "rouge-l": 0.16,
          "bertscore": {
            "precision": 0.8643,
            "recall": 0.825,
            "f1": 0.8442
          }
        }
      }
    ]
  },
  {
    "code": "from math import * NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT sr = sqrt ( x ) NEW_LINE return ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE DEDENT def checkSunnyNumber ( N ) : NEW_LINE INDENT if ( isPerfectSquare ( N + 1 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 8 NEW_LINE checkSunnyNumber ( N ) NEW_LINE DEDENT",
    "summary": {
      "ideal": "Sunny Number",
      "generated": "Check if N+1 is a perfect square",
      "metrics": {
        "bleu": 0,
        "rouge-1": 0.0,
        "rouge-2": 0.0,
        "rouge-l": 0.0,
        "bertscore": {
          "precision": 0.8101,
          "recall": 0.855,
          "f1": 0.8319
        }
      }
    },
    "query": [
      {
        "query1": "Python code to check if a number is sunny number (N+1 is perfect square)",
        "metrics": {
          "bleu": 0,
          "rouge-1": 0.0,
          "rouge-2": 0.0,
          "rouge-l": 0.0,
          "bertscore": {
            "precision": 0.8095,
            "recall": 0.8835,
            "f1": 0.8449
          }
        }
      },
      {
        "query2": "Python code to check if a number is sunny",
        "metrics": {
          "bleu": 0,
          "rouge-1": 0.0,
          "rouge-2": 0.0,
          "rouge-l": 0.0,
          "bertscore": {
            "precision": 0.8261,
            "recall": 0.8936,
            "f1": 0.8586
          }
        }
      },
      {
        "query3": "python function to check if a number is a sunny number",
        "metrics": {
          "bleu": 0,
          "rouge-1": 0.0,
          "rouge-2": 0.0,
          "rouge-l": 0.0,
          "bertscore": {
            "precision": 0.8264,
            "recall": 0.8895,
            "f1": 0.8567
          }
        }
      }
    ]
  },
  {
    "code": "def countValues ( n ) : NEW_LINE INDENT answer = 0 NEW_LINE for i in range ( 2 , n + 1 , 1 ) : NEW_LINE INDENT k = n NEW_LINE while ( k >= i ) : NEW_LINE INDENT if ( k % i == 0 ) : NEW_LINE INDENT k //= i NEW_LINE DEDENT else : NEW_LINE INDENT k -= i NEW_LINE DEDENT DEDENT if ( k == 1 ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 6 NEW_LINE print ( countValues ( N ) ) NEW_LINE DEDENT",
    "summary": {
      "ideal": "Count the numbers which can convert N to 1 using given operation",
      "generated": "Count values of i where n reduced to 1 using operations",
      "metrics": {
        "bleu": 0.0,
        "rouge-1": 0.3478,
        "rouge-2": 0.1905,
        "rouge-l": 0.3478,
        "bertscore": {
          "precision": 0.8922,
          "recall": 0.8891,
          "f1": 0.8907
        }
      }
    },
    "query": [
      {
        "query1": "Python code to count values satisfying divisibility condition",
        "metrics": {
          "bleu": 0.0,
          "rouge-1": 0.1,
          "rouge-2": 0.0,
          "rouge-l": 0.1,
          "bertscore": {
            "precision": 0.8562,
            "recall": 0.8581,
            "f1": 0.8572
          }
        }
      },
      {
        "query2": "Python code to count values satisfying specific condition",
        "metrics": {
          "bleu": 0.0,
          "rouge-1": 0.1,
          "rouge-2": 0.0,
          "rouge-l": 0.1,
          "bertscore": {
            "precision": 0.8685,
            "recall": 0.8623,
            "f1": 0.8654
          }
        }
      },
      {
        "query3": "python function to count valid values for modular arithmetic",
        "metrics": {
          "bleu": 0.0,
          "rouge-1": 0.0952,
          "rouge-2": 0.0,
          "rouge-l": 0.0952,
          "bertscore": {
            "precision": 0.8645,
            "recall": 0.8572,
            "f1": 0.8608
          }
        }
      }
    ]
  },
  {
    "code": "def printKNumbers ( N , K ) : NEW_LINE INDENT for i in range ( K - 1 ) : NEW_LINE INDENT print ( 1 , end = ' ▁ ' ) NEW_LINE DEDENT print ( N - K + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT ( N , K ) = ( 10 , 3 ) NEW_LINE printKNumbers ( N , K ) NEW_LINE DEDENT",
    "summary": {
      "ideal": "Find K numbers with sum equal to N and sum of their squares maximized",
      "generated": "Print K numbers summing to N",
      "metrics": {
        "bleu": 0.0,
        "rouge-1": 0.4211,
        "rouge-2": 0.2222,
        "rouge-l": 0.4211,
        "bertscore": {
          "precision": 0.9054,
          "recall": 0.8587,
          "f1": 0.8814
        }
      }
    },
    "query": [
      {
        "query1": "Python code to print K numbers with sum N using 1's and one large number",
        "metrics": {
          "bleu": 0.1892,
          "rouge-1": 0.5,
          "rouge-2": 0.2222,
          "rouge-l": 0.4286,
          "bertscore": {
            "precision": 0.8773,
            "recall": 0.8838,
            "f1": 0.8805
          }
        }
      },
      {
        "query2": "Python code to print K numbers with sum N",
        "metrics": {
          "bleu": 0.1895,
          "rouge-1": 0.5455,
          "rouge-2": 0.2857,
          "rouge-l": 0.4545,
          "bertscore": {
            "precision": 0.9048,
            "recall": 0.8798,
            "f1": 0.8921
          }
        }
      },
      {
        "query3": "python function to print K numbers that sum up to N",
        "metrics": {
          "bleu": 0.0,
          "rouge-1": 0.4348,
          "rouge-2": 0.1739,
          "rouge-l": 0.4348,
          "bertscore": {
            "precision": 0.8946,
            "recall": 0.8781,
            "f1": 0.8863
          }
        }
      }
    ]
  },
  {
    "code": "def NthSmallest ( K ) : NEW_LINE INDENT Q = [ ] NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT Q . append ( i ) NEW_LINE DEDENT for i in range ( 1 , K + 1 ) : NEW_LINE INDENT x = Q [ 0 ] NEW_LINE Q . remove ( Q [ 0 ] ) NEW_LINE if ( x % 10 != 0 ) : NEW_LINE INDENT Q . append ( x * 10 + x % 10 - 1 ) NEW_LINE DEDENT Q . append ( x * 10 + x % 10 ) NEW_LINE if ( x % 10 != 9 ) : NEW_LINE INDENT Q . append ( x * 10 + x % 10 + 1 ) NEW_LINE DEDENT DEDENT return x NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 16 NEW_LINE print ( NthSmallest ( N ) ) NEW_LINE DEDENT",
    "summary": {
      "ideal": "Print Nth Stepping or Autobiographical number",
      "generated": "Find Nth smallest number with specific digit conditions",
      "metrics": {
        "bleu": 0.0,
        "rouge-1": 0.2857,
        "rouge-2": 0.0,
        "rouge-l": 0.2857,
        "bertscore": {
          "precision": 0.8661,
          "recall": 0.853,
          "f1": 0.8595
        }
      }
    },
    "query": [
      {
        "query1": "Python code to find Nth smallest number with specific digit pattern",
        "metrics": {
          "bleu": 0.0,
          "rouge-1": 0.2353,
          "rouge-2": 0.0,
          "rouge-l": 0.2353,
          "bertscore": {
            "precision": 0.8489,
            "recall": 0.8429,
            "f1": 0.8459
          }
        }
      },
      {
        "query2": "Python code to find Nth smallest number with specific digits",
        "metrics": {
          "bleu": 0.0,
          "rouge-1": 0.25,
          "rouge-2": 0.0,
          "rouge-l": 0.25,
          "bertscore": {
            "precision": 0.8526,
            "recall": 0.8442,
            "f1": 0.8484
          }
        }
      },
      {
        "query3": "python function to find the Nth smallest number with specific digits",
        "metrics": {
          "bleu": 0.0,
          "rouge-1": 0.2353,
          "rouge-2": 0.0,
          "rouge-l": 0.2353,
          "bertscore": {
            "precision": 0.8448,
            "recall": 0.8368,
            "f1": 0.8407
          }
        }
      }
    ]
  },
  {
    "code": "from math import sqrt NEW_LINE def nearest ( n ) : NEW_LINE INDENT prevSquare = int ( sqrt ( n ) ) ; NEW_LINE nextSquare = prevSquare + 1 ; NEW_LINE prevSquare = prevSquare * prevSquare ; NEW_LINE nextSquare = nextSquare * nextSquare ; NEW_LINE ans = ( prevSquare - n ) if ( n - prevSquare ) < ( nextSquare - n ) else ( nextSquare - n ) ; NEW_LINE return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 14 ; NEW_LINE print ( nearest ( n ) ) ; NEW_LINE n = 16 ; NEW_LINE print ( nearest ( n ) ) ; NEW_LINE n = 18 ; NEW_LINE print ( nearest ( n ) ) ; NEW_LINE DEDENT",
    "summary": {
      "ideal": "Least number to be added to or subtracted from N to make it a Perfect Square",
      "generated": "Find nearest perfect square to a number",
      "metrics": {
        "bleu": 0.0,
        "rouge-1": 0.2857,
        "rouge-2": 0.0,
        "rouge-l": 0.1905,
        "bertscore": {
          "precision": 0.8964,
          "recall": 0.8267,
          "f1": 0.8601
        }
      }
    },
    "query": [
      {
        "query1": "Python code to find nearest perfect square difference",
        "metrics": {
          "bleu": 0.0,
          "rouge-1": 0.0909,
          "rouge-2": 0.0,
          "rouge-l": 0.0909,
          "bertscore": {
            "precision": 0.8719,
            "recall": 0.8296,
            "f1": 0.8502
          }
        }
      },
      {
        "query2": "Python code to find nearest perfect square",
        "metrics": {
          "bleu": 0.0,
          "rouge-1": 0.0952,
          "rouge-2": 0.0,
          "rouge-l": 0.0952,
          "bertscore": {
            "precision": 0.8793,
            "recall": 0.8283,
            "f1": 0.8531
          }
        }
      },
      {
        "query3": "python function to find the nearest square number difference",
        "metrics": {
          "bleu": 0.0,
          "rouge-1": 0.1739,
          "rouge-2": 0.0,
          "rouge-l": 0.087,
          "bertscore": {
            "precision": 0.8755,
            "recall": 0.8289,
            "f1": 0.8515
          }
        }
      }
    ]
  },
  {
    "code": "from math import acos NEW_LINE def printValueOfPi ( N ) : NEW_LINE INDENT b = ' { : . ' + str ( N ) + ' f } ' NEW_LINE pi = b . format ( 2 * acos ( 0.0 ) ) NEW_LINE print ( pi ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 43 ; NEW_LINE printValueOfPi ( N ) ; NEW_LINE DEDENT",
    "summary": {
      "ideal": "Value of Pi ( Î ) up to 50 decimal places",
      "generated": "Print pi with N decimal precision",
      "metrics": {
        "bleu": 0.0,
        "rouge-1": 0.1176,
        "rouge-2": 0.0,
        "rouge-l": 0.1176,
        "bertscore": {
          "precision": 0.876,
          "recall": 0.8458,
          "f1": 0.8606
        }
      }
    },
    "query": [
      {
        "query1": "Python code to print value of pi with N decimal places",
        "metrics": {
          "bleu": 0.0,
          "rouge-1": 0.3636,
          "rouge-2": 0.1,
          "rouge-l": 0.2727,
          "bertscore": {
            "precision": 0.8646,
            "recall": 0.8496,
            "f1": 0.857
          }
        }
      },
      {
        "query2": "Python code to print value of pi with N decimals",
        "metrics": {
          "bleu": 0.0,
          "rouge-1": 0.1905,
          "rouge-2": 0.0,
          "rouge-l": 0.0952,
          "bertscore": {
            "precision": 0.8357,
            "recall": 0.8346,
            "f1": 0.8351
          }
        }
      },
      {
        "query3": "python function to print value of pi with N decimal places",
        "metrics": {
          "bleu": 0.0,
          "rouge-1": 0.3636,
          "rouge-2": 0.1,
          "rouge-l": 0.2727,
          "bertscore": {
            "precision": 0.8646,
            "recall": 0.8503,
            "f1": 0.8574
          }
        }
      }
    ]
  },
  {
    "code": "import math NEW_LINE def decBinary ( arr , n ) : NEW_LINE INDENT k = int ( math . log2 ( n ) ) NEW_LINE while ( n > 0 ) : NEW_LINE INDENT arr [ k ] = n % 2 NEW_LINE k = k - 1 NEW_LINE n = n // 2 NEW_LINE DEDENT DEDENT def binaryDec ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT ans = ans + ( arr [ i ] << ( n - i - 1 ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def getNum ( n , k ) : NEW_LINE INDENT l = int ( math . log2 ( n ) ) + 1 NEW_LINE a = [ 0 for i in range ( 0 , l ) ] NEW_LINE decBinary ( a , n ) NEW_LINE if ( k > l ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( a [ k - 1 ] == 0 ) : NEW_LINE INDENT a [ k - 1 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT a [ k - 1 ] = 0 NEW_LINE DEDENT return binaryDec ( a , l ) NEW_LINE DEDENT n = 56 NEW_LINE k = 2 NEW_LINE print ( getNum ( n , k ) ) NEW_LINE",
    "summary": {
      "ideal": "Invert the Kth most significant bit of N",
      "generated": "Toggle k-th bit of a number and return new value",
      "metrics": {
        "bleu": 0.0,
        "rouge-1": 0.2222,
        "rouge-2": 0.125,
        "rouge-l": 0.2222,
        "bertscore": {
          "precision": 0.867,
          "recall": 0.8513,
          "f1": 0.8591
        }
      }
    },
    "query": [
      {
        "query1": "Python code to toggle Kth bit of a number and return decimal value",
        "metrics": {
          "bleu": 0.0,
          "rouge-1": 0.2857,
          "rouge-2": 0.1053,
          "rouge-l": 0.2857,
          "bertscore": {
            "precision": 0.8796,
            "recall": 0.862,
            "f1": 0.8707
          }
        }
      },
      {
        "query2": "Python code to toggle bit at position K and convert decimal to binary",
        "metrics": {
          "bleu": 0.0,
          "rouge-1": 0.1,
          "rouge-2": 0.0,
          "rouge-l": 0.1,
          "bertscore": {
            "precision": 0.858,
            "recall": 0.8429,
            "f1": 0.8504
          }
        }
      },
      {
        "query3": "python function to flip the k-th bit of a number and return the result",
        "metrics": {
          "bleu": 0.0,
          "rouge-1": 0.2857,
          "rouge-2": 0.1,
          "rouge-l": 0.2857,
          "bertscore": {
            "precision": 0.8806,
            "recall": 0.8742,
            "f1": 0.8774
          }
        }
      }
    ]
  },
  {
    "code": "MAX = 1000000 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE result = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE fact = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE def preCompute ( ) : NEW_LINE INDENT fact [ 0 ] = 1 NEW_LINE result [ 0 ] = 1 NEW_LINE for i in range ( 1 , MAX + 1 ) : NEW_LINE INDENT fact [ i ] = ( ( fact [ i - 1 ] % MOD ) * i ) % MOD NEW_LINE result [ i ] = ( ( result [ i - 1 ] % MOD ) * ( fact [ i ] % MOD ) ) % MOD NEW_LINE DEDENT DEDENT def performQueries ( q , n ) : NEW_LINE INDENT preCompute ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( result [ q [ i ] ] ) NEW_LINE DEDENT DEDENT q = [ 4 , 5 ] NEW_LINE n = len ( q ) NEW_LINE performQueries ( q , n ) NEW_LINE",
    "summary": {
      "ideal": "Queries for the product of first N factorials",
      "generated": "Precompute factorial results for queries",
      "metrics": {
        "bleu": 0.0,
        "rouge-1": 0.1538,
        "rouge-2": 0.0,
        "rouge-l": 0.1538,
        "bertscore": {
          "precision": 0.8419,
          "recall": 0.8628,
          "f1": 0.8522
        }
      }
    },
    "query": [
      {
        "query1": "Python code to precompute factorial products and answer queries",
        "metrics": {
          "bleu": 0,
          "rouge-1": 0.0,
          "rouge-2": 0.0,
          "rouge-l": 0.0,
          "bertscore": {
            "precision": 0.8526,
            "recall": 0.8674,
            "f1": 0.8599
          }
        }
      },
      {
        "query2": "Python code to precompute factorial and result for queries",
        "metrics": {
          "bleu": 0.0,
          "rouge-1": 0.1176,
          "rouge-2": 0.0,
          "rouge-l": 0.1176,
          "bertscore": {
            "precision": 0.8501,
            "recall": 0.8577,
            "f1": 0.8539
          }
        }
      },
      {
        "query3": "python function to compute factorial result for a list of queries",
        "metrics": {
          "bleu": 0.0,
          "rouge-1": 0.2105,
          "rouge-2": 0.0,
          "rouge-l": 0.2105,
          "bertscore": {
            "precision": 0.8721,
            "recall": 0.8664,
            "f1": 0.8693
          }
        }
      }
    ]
  },
  {
    "code": "import sys NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b ; NEW_LINE DEDENT return gcd ( b % a , a ) ; NEW_LINE DEDENT def divTermCount ( a , b , c , num ) : NEW_LINE INDENT return ( ( num / a ) + ( num / b ) + ( num / c ) - ( num / ( ( a * b ) / gcd ( a , b ) ) ) - ( num / ( ( c * b ) / gcd ( c , b ) ) ) - ( num / ( ( a * c ) / gcd ( a , c ) ) ) + ( num / ( ( a * b * c ) / gcd ( gcd ( a , b ) , c ) ) ) ) ; NEW_LINE DEDENT def findNthTerm ( a , b , c , n ) : NEW_LINE INDENT low = 1 ; high = sys . maxsize ; mid = 0 ; NEW_LINE while ( low < high ) : NEW_LINE INDENT mid = low + ( high - low ) / 2 ; NEW_LINE if ( divTermCount ( a , b , c , mid ) < n ) : NEW_LINE INDENT low = mid + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT high = mid ; NEW_LINE DEDENT DEDENT return int ( low ) ; NEW_LINE DEDENT a = 2 ; b = 3 ; c = 5 ; n = 100 ; NEW_LINE print ( findNthTerm ( a , b , c , n ) ) ; NEW_LINE",
    "summary": {
      "ideal": "Nth number in a set of multiples of A , B or C",
      "generated": "Find Nth term divisible by a, b, or c",
      "metrics": {
        "bleu": 0.0,
        "rouge-1": 0.1905,
        "rouge-2": 0.0,
        "rouge-l": 0.1905,
        "bertscore": {
          "precision": 0.9075,
          "recall": 0.8935,
          "f1": 0.9005
        }
      }
    },
    "query": [
      {
        "query1": "Python code to find Nth term divisible by a, b, or c using inclusion-exclusion",
        "metrics": {
          "bleu": 0.0,
          "rouge-1": 0.1538,
          "rouge-2": 0.0,
          "rouge-l": 0.1538,
          "bertscore": {
            "precision": 0.8712,
            "recall": 0.8906,
            "f1": 0.8808
          }
        }
      },
      {
        "query2": "Python code to find Nth term divisible by a, b, or c",
        "metrics": {
          "bleu": 0.0,
          "rouge-1": 0.1667,
          "rouge-2": 0.0,
          "rouge-l": 0.1667,
          "bertscore": {
            "precision": 0.8921,
            "recall": 0.8921,
            "f1": 0.8921
          }
        }
      },
      {
        "query3": "python function to find the nth term divisible by a, b, or c",
        "metrics": {
          "bleu": 0.0,
          "rouge-1": 0.08,
          "rouge-2": 0.0,
          "rouge-l": 0.08,
          "bertscore": {
            "precision": 0.893,
            "recall": 0.8965,
            "f1": 0.8947
          }
        }
      }
    ]
  },
  {
    "code": "def calculate_angle ( n , i , j , k ) : NEW_LINE INDENT x , y = 0 , 0 NEW_LINE if ( i < j ) : NEW_LINE INDENT x = j - i NEW_LINE DEDENT else : NEW_LINE INDENT x = j + n - i NEW_LINE DEDENT if ( j < k ) : NEW_LINE INDENT y = k - j NEW_LINE DEDENT else : NEW_LINE INDENT y = k + n - j NEW_LINE DEDENT ang1 = ( 180 * x ) // n NEW_LINE ang2 = ( 180 * y ) // n NEW_LINE ans = 180 - ang1 - ang2 NEW_LINE return ans NEW_LINE DEDENT n = 5 NEW_LINE a1 = 1 NEW_LINE a2 = 2 NEW_LINE a3 = 5 NEW_LINE print ( calculate_angle ( n , a1 , a2 , a3 ) ) NEW_LINE",
    "summary": {
      "ideal": "Angle between 3 given vertices in a n",
      "generated": "Calculate angle within a polygon with n sides",
      "metrics": {
        "bleu": 0.0,
        "rouge-1": 0.25,
        "rouge-2": 0.0,
        "rouge-l": 0.25,
        "bertscore": {
          "precision": 0.8368,
          "recall": 0.8501,
          "f1": 0.8434
        }
      }
    },
    "query": [
      {
        "query1": "Python code to calculate angle between three points on polygon",
        "metrics": {
          "bleu": 0.0,
          "rouge-1": 0.1111,
          "rouge-2": 0.0,
          "rouge-l": 0.1111,
          "bertscore": {
            "precision": 0.8589,
            "recall": 0.8495,
            "f1": 0.8542
          }
        }
      },
      {
        "query2": "Python code to calculate angle based on points on a circle",
        "metrics": {
          "bleu": 0.0,
          "rouge-1": 0.1111,
          "rouge-2": 0.0,
          "rouge-l": 0.1111,
          "bertscore": {
            "precision": 0.8518,
            "recall": 0.8219,
            "f1": 0.8366
          }
        }
      },
      {
        "query3": "python function to calculate the angle between three points on a circle",
        "metrics": {
          "bleu": 0.0,
          "rouge-1": 0.2,
          "rouge-2": 0.0,
          "rouge-l": 0.2,
          "bertscore": {
            "precision": 0.872,
            "recall": 0.8555,
            "f1": 0.8637
          }
        }
      }
    ]
  }
]